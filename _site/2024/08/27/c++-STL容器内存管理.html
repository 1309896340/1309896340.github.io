<!DOCTYPE html>
<html lang=" en-US">

<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/assets/css/style.css?v=6c8e69270e46e7caefd208c690b7a69a9efbaeef">
  <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup theme-color -->
<!-- start theme color meta headers -->
<meta name="theme-color" content="#151515">
<meta name="msapplication-navbutton-color" content="#151515">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- end theme color meta headers -->


<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->




<script type="module">
    // import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10.0.2/+esm';
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
    mermaid.initialize({
        startOnLoad: false,
        // securityLevel: 'loose',
        theme: 'dark'
    });
    await mermaid.run({
        querySelector: '.language-mermaid',
    });
</script>


<!-- end custom head snippets -->
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>C++内存管理 | Windwhisper’s Blog</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="C++内存管理" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="STL容器内存管理" />
<meta property="og:description" content="STL容器内存管理" />
<link rel="canonical" href="http://localhost:4000/2024/08/27/c++-STL%E5%AE%B9%E5%99%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html" />
<meta property="og:url" content="http://localhost:4000/2024/08/27/c++-STL%E5%AE%B9%E5%99%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html" />
<meta property="og:site_name" content="Windwhisper’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-08-27T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="C++内存管理" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-08-27T00:00:00+08:00","datePublished":"2024-08-27T00:00:00+08:00","description":"STL容器内存管理","headline":"C++内存管理","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2024/08/27/c++-STL%E5%AE%B9%E5%99%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"},"url":"http://localhost:4000/2024/08/27/c++-STL%E5%AE%B9%E5%99%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body>

  <header>
    <div class="container">
      <a id="a-title" href="/">
        <h1>Windwhisper's Blog</h1>
      </a>
      <h2>个人博客，归纳分享所学技术</h2>

      <section id="downloads">
        
        <a href="https://github.com/1309896340/1309896340.github.io" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
      </section>
    </div>
  </header>

  <div class="container">
    <section id="main_content">
      <small>27 August 2024</small>
<h1>C++内存管理</h1>

<!-- <p class="view">by </p> -->


<ul><li><a href="#stl容器内存管理">STL容器内存管理</a><ul><li><a href="#问题引出">问题引出</a><ul><li><a href="#栈变量与堆变量">栈变量与堆变量</a></li></ul></li><li><a href="#动态内存谁来管">动态内存谁来管？</a><ul><li><a href="#自动和手动">自动和手动</a></li><li><a href="#指针的备份">指针的备份</a><ul><li><a href="#一个典型的错误示例">一个典型的错误示例</a></li><li><a href="#发生了什么">发生了什么？</a></li></ul></li></ul></li></ul></li></ul>

<h1 id="stl容器内存管理">STL容器内存管理</h1>

<p>在使用STL容器时，需要面对各种可能数据类型进行管理，它们有的是基本数据类型，有的是结构体、有的是类对象，也有的是这些类型的指针，或是其他更加复杂的复合形式。在如此复杂的情形下，稍有不慎就会导致野指针、内存泄漏等问题，本文就如何正确处理这些问题做一个归纳总结。</p>

<h2 id="问题引出">问题引出</h2>

<h3 id="栈变量与堆变量">栈变量与堆变量</h3>

<p>声明在栈上的变量，其生命周期被限制在各自的作用域上，脱离作用域，变量自动释放</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>     <span class="c1">// a作用域的开始</span>
    <span class="c1">// a存在的作用域</span>
<span class="p">}</span>   <span class="c1">// 函数返回，a自动释放</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="c1">// a 不存在于函数外的作用域名</span>
    <span class="n">func</span><span class="p">();</span>
    <span class="c1">// a 不存在于函数外的作用域名</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>声明在堆上的变量，即便指向它的指针被释放，堆变量也仍然存在，只是程序再也无法控制这段内存，所以被称为<strong>内存泄漏</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>
    <span class="c1">// 申请但没有释放，内存泄漏</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">func</span><span class="p">();</span>
    <span class="c1">// ptr在func()返回时被释放，再也没有任何方法访问new申请的int内存空间</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里要注意的是</p>
<ol>
  <li>在 <code class="language-plaintext highlighter-rouge">func()</code> 中，<code class="language-plaintext highlighter-rouge">ptr</code> 是栈变量，而 <code class="language-plaintext highlighter-rouge">ptr</code> 指向的内存空间是堆空间</li>
  <li><code class="language-plaintext highlighter-rouge">ptr</code> 在 <code class="language-plaintext highlighter-rouge">func()</code> 返回时会自动释放，而 <code class="language-plaintext highlighter-rouge">ptr</code> 指向的内存不会</li>
</ol>

<p>因此，动态内存(堆内存)的使用，必须有始有终。</p>

<ul>
  <li>在C语言中，有 <code class="language-plaintext highlighter-rouge">malloc()</code> 就有 <code class="language-plaintext highlighter-rouge">free()</code></li>
  <li>在C++中，有 <code class="language-plaintext highlighter-rouge">new</code> 就有 <code class="language-plaintext highlighter-rouge">delete</code></li>
</ul>

<p>两者必须一一对应，否则：</p>

<ul>
  <li>“申请”比”释放”多：内存泄漏</li>
  <li>“申请”比”释放”少：多次释放</li>
</ul>

<h2 id="动态内存谁来管">动态内存谁来管？</h2>

<h3 id="自动和手动">自动和手动</h3>

<ol>
  <li>在C语言中，对于使用了动态内存的代码封装，一般都有一对明确的”初始化”和”销毁”操作，例如文件io操作中的 <code class="language-plaintext highlighter-rouge">open()</code> 和 <code class="language-plaintext highlighter-rouge">close()</code></li>
  <li>在c++中，一般在构造函数中申请堆内存，在析构函数中释放堆内存(需要手动编写释放逻辑)。</li>
</ol>

<p>c++中，类的实例化分为”栈实例化”与”堆实例化”</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="nl">public:</span>
        <span class="n">A</span><span class="p">()</span><span class="o">:</span><span class="n">data</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">){}</span>
        <span class="o">~</span><span class="n">A</span><span class="p">(){</span><span class="k">delete</span> <span class="n">data</span><span class="p">;}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">A</span> <span class="n">a</span><span class="p">;</span>                <span class="c1">// 栈实例化，调用构造，a.data申请动态内存</span>
    <span class="n">A</span> <span class="o">*</span><span class="n">pa</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="p">;</span>      <span class="c1">// 堆实例化，调用构造，pa-&gt;data申请动态内存</span>
    <span class="n">A</span> <span class="o">*</span><span class="n">pa_ok</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">pa_ok</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// 栈变量a自动释放，触发析构函数释放a.data指向的堆内存</span>
    <span class="c1">// 栈变量pa自动释放，但是*pa和pa-&gt;data都没有释放，这两个堆内存空间泄漏</span>
    <span class="c1">// 栈变量pa_ok自动释放，在这之前，析构函数被自动调用</span>
    <span class="c1">// pa_ok-&gt;data指向的堆空间先释放，而后pa_ok指向的声明在堆空间上的A实例被释放，最后栈变量pa_ok被释放</span>
<span class="p">}</span>
</code></pre></div></div>

<p>正因为动态内存的管理中同时存在着”自动”和”手动”两种行为，因此很容易出现”多释放”和”漏释放”两种情况。</p>

<p>因此，明确谁是这块堆空间的实际管理者，非常重要。</p>

<h3 id="指针的备份">指针的备份</h3>

<p>指针是堆内存的控制杆(handler)，丢失了控制杆就丢失了堆内存(泄漏)。然而，指针可以不唯一，这就导致了<strong>多重释放</strong>的潜在风险。</p>

<h4 id="一个典型的错误示例">一个典型的错误示例</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="nl">public:</span>
        <span class="n">A</span><span class="p">()</span><span class="o">:</span><span class="n">data</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">){</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"构造函数初始化 this=%#x data=%#x</span><span class="se">\\</span><span class="s">n"</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="o">~</span><span class="n">A</span><span class="p">(){</span>
            <span class="k">delete</span> <span class="n">data</span><span class="p">;</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"析构函数调用 this=%#x</span><span class="se">\\</span><span class="s">n"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">func_value</span><span class="p">(</span><span class="n">A</span> <span class="n">p</span><span class="p">){}</span>       <span class="c1">// 空函数，只为了演示值传递的效果</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">func_value</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// 在结束时会发生报错</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>严谨地来说，”指针”是存储地址的变量，但有时为了表述方便，会直接称呼”地址”为”指针”，因为我们倾向于将变量的概念等同于其存储的值的概念，这在一定程度上造成了混淆，需要结合语境进行区分。例如，指针传递实际上是地址值的传递。</p>
</blockquote>

<p>以上代码在执行到主函数的返回时会发生报错，报错位置在类A析构函数的 <code class="language-plaintext highlighter-rouge">delete data;</code> 行</p>

<h4 id="发生了什么">发生了什么？</h4>

<p>类对象的值传递默认为”浅拷贝”，即拷贝所有成员变量的”值”，对指针而言，地址值的复制意味着多了一个指针指向同一块堆内存</p>

<pre><code class="language-mermaid">    graph LR
    ptr1[a.data] --&gt; a[堆内存]
    ptr2[p.data] --&gt; a
</code></pre>

<p>对象的值传递导致指针也复制了一份，而函数的形式参数同时也是该函数的局部变量，还是个栈变量，当 <code class="language-plaintext highlighter-rouge">func_value()</code> 中</p>



<!-- 
  <small>tags: <em></em></small>
 -->
    </section>
  </div>
</body>

</html>