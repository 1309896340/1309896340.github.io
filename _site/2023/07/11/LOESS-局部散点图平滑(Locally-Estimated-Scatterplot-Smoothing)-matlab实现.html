<!DOCTYPE html>
<html lang=" en-US">

<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/assets/css/style.css?v=420a830fd2899b122cc49ab5bd2872bd01a025a5">
  <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup theme-color -->
<!-- start theme color meta headers -->
<meta name="theme-color" content="#151515">
<meta name="msapplication-navbutton-color" content="#151515">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- end theme color meta headers -->


<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        TeX: {
          equationNumbers: {
            autoNumber: "AMS"
          }
        },
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true,
        "HTML-CSS": { fonts: ["TeX"] }
      }
    });
    MathJax.Hub.Register.MessageHook("Math Processing Error",function (message) {
          alert("Math Processing Error: "+message[1]);
        });
    MathJax.Hub.Register.MessageHook("TeX Jax - parse error",function (message) {
          alert("Math Processing Error: "+message[1]);
        });
  </script>
  <script
    type="text/javascript"
    async
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"
  ></script>




<!-- end custom head snippets -->
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>LOESS：局部散点图平滑(Locally Estimated Scatterplot Smoothing) matlab实现 | Windwhisper’s Blog</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="LOESS：局部散点图平滑(Locally Estimated Scatterplot Smoothing) matlab实现" />
<meta name="author" content="Windwhisper" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="前言 最近在学习时间序列预测，需要使用STL算法对时间序列进行季节性趋势分离，而其中使用到一个称作LOESS的平滑算法。 本文是对1990年一篇有关时间序列分析论文中提及的LOESS算法的部分解读，并基于matlab实现" />
<meta property="og:description" content="前言 最近在学习时间序列预测，需要使用STL算法对时间序列进行季节性趋势分离，而其中使用到一个称作LOESS的平滑算法。 本文是对1990年一篇有关时间序列分析论文中提及的LOESS算法的部分解读，并基于matlab实现" />
<link rel="canonical" href="http://localhost:4000/2023/07/11/LOESS-%E5%B1%80%E9%83%A8%E6%95%A3%E7%82%B9%E5%9B%BE%E5%B9%B3%E6%BB%91(Locally-Estimated-Scatterplot-Smoothing)-matlab%E5%AE%9E%E7%8E%B0.html" />
<meta property="og:url" content="http://localhost:4000/2023/07/11/LOESS-%E5%B1%80%E9%83%A8%E6%95%A3%E7%82%B9%E5%9B%BE%E5%B9%B3%E6%BB%91(Locally-Estimated-Scatterplot-Smoothing)-matlab%E5%AE%9E%E7%8E%B0.html" />
<meta property="og:site_name" content="Windwhisper’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-07-11T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="LOESS：局部散点图平滑(Locally Estimated Scatterplot Smoothing) matlab实现" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Windwhisper"},"dateModified":"2023-07-11T00:00:00+08:00","datePublished":"2023-07-11T00:00:00+08:00","description":"前言 最近在学习时间序列预测，需要使用STL算法对时间序列进行季节性趋势分离，而其中使用到一个称作LOESS的平滑算法。 本文是对1990年一篇有关时间序列分析论文中提及的LOESS算法的部分解读，并基于matlab实现","headline":"LOESS：局部散点图平滑(Locally Estimated Scatterplot Smoothing) matlab实现","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2023/07/11/LOESS-%E5%B1%80%E9%83%A8%E6%95%A3%E7%82%B9%E5%9B%BE%E5%B9%B3%E6%BB%91(Locally-Estimated-Scatterplot-Smoothing)-matlab%E5%AE%9E%E7%8E%B0.html"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/icons/favicon.ico"},"name":"Windwhisper"},"url":"http://localhost:4000/2023/07/11/LOESS-%E5%B1%80%E9%83%A8%E6%95%A3%E7%82%B9%E5%9B%BE%E5%B9%B3%E6%BB%91(Locally-Estimated-Scatterplot-Smoothing)-matlab%E5%AE%9E%E7%8E%B0.html"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body>

  <header>
    <div class="container">
      <a id="a-title" href="/">
        <h1>Windwhisper's Blog</h1>
      </a>
      <h2>个人博客，归纳分享</h2>

      <section id="downloads">
        
        <a href="https://github.com/1309896340/1309896340.github.io" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
      </section>
    </div>
  </header>

  <div class="container">
    <section id="main_content">
      <small>11 July 2023</small>
<h1>LOESS：局部散点图平滑(Locally Estimated Scatterplot Smoothing) matlab实现</h1>

<!-- <p class="view">by Windwhisper</p> -->

<h2 id="前言">前言</h2>
<p>最近在学习时间序列预测，需要使用STL算法对时间序列进行季节性趋势分离，而其中使用到一个称作LOESS的平滑算法。
本文是对1990年一篇有关时间序列分析论文中提及的LOESS算法的部分解读，并基于matlab实现</p>

<p><a href="https://scholar.google.co.jp/scholar_url?url=http://www.nniiem.ru/file/news/2016/stl-statistical-model.pdf&amp;hl=zh-CN&amp;sa=X&amp;ei=oqOsZNqyCaSK6rQPhqKGiAE&amp;scisig=ABFrs3yOkcuHV4Q4StOGq9vmlX1X&amp;oi=scholarr">STL: A Seasonal-Trend Decomposition Procedure Based on Loess</a></p>

<h2 id="数据来源">数据来源</h2>
<p>在google earth engine上获取2002年到2018年共17年的全球温度月(平均)数据，空间分辨率0.5°，时间分辨率1月
(获取数据需要特殊网络环境)</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d2</span> <span class="o">=</span> <span class="nx">ee</span><span class="p">.</span><span class="nx">ImageCollection</span><span class="p">(</span><span class="dl">"</span><span class="s2">ECMWF/ERA5/DAILY</span><span class="dl">"</span><span class="p">).</span><span class="nx">filterDate</span><span class="p">(</span><span class="dl">"</span><span class="s2">2002-01-01</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">2019-01-01</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">start_t</span> <span class="o">=</span> <span class="nx">ee</span><span class="p">.</span><span class="nb">Date</span><span class="p">(</span><span class="dl">"</span><span class="s2">2002-01-01</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">sq</span> <span class="o">=</span> <span class="nx">ee</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nx">sequence</span><span class="p">({</span>
    <span class="na">start</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="na">end</span><span class="p">:</span> <span class="mi">12</span><span class="o">*</span><span class="mi">17</span>
<span class="p">});</span>
<span class="kd">var</span> <span class="nx">d2</span> <span class="o">=</span> <span class="nx">ee</span><span class="p">.</span><span class="nx">ImageCollection</span><span class="p">(</span><span class="nx">sq</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">m</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">start_d</span> <span class="o">=</span> <span class="nx">start_t</span><span class="p">.</span><span class="nx">advance</span><span class="p">(</span><span class="nx">ee</span><span class="p">.</span><span class="nb">Number</span><span class="p">(</span><span class="nx">m</span><span class="p">).</span><span class="nx">subtract</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="dl">"</span><span class="s2">month</span><span class="dl">"</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">end_d</span> <span class="o">=</span> <span class="nx">start_d</span><span class="p">.</span><span class="nx">advance</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="dl">"</span><span class="s2">month</span><span class="dl">"</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">new_d</span> <span class="o">=</span> <span class="nx">d2</span><span class="p">.</span><span class="nx">filterDate</span><span class="p">(</span><span class="nx">start_d</span><span class="p">,</span><span class="nx">end_d</span><span class="p">).</span><span class="nx">mean</span><span class="p">()</span>
        <span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">"</span><span class="s2">system:time_start</span><span class="dl">"</span><span class="p">,</span><span class="nx">start_d</span><span class="p">.</span><span class="nx">millis</span><span class="p">());</span>
    <span class="k">return</span> <span class="nx">new_d</span><span class="p">;</span>
<span class="p">}));</span>
<span class="kd">var</span> <span class="nx">TMP</span> <span class="o">=</span> <span class="nx">d2</span><span class="p">.</span><span class="nx">select</span><span class="p">(</span><span class="dl">"</span><span class="s2">mean_2m_air_temperature</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">Export</span><span class="p">.</span><span class="nx">image</span><span class="p">.</span><span class="nx">toDrive</span><span class="p">({</span>
    <span class="na">image</span><span class="p">:</span> <span class="nx">TMP</span><span class="p">.</span><span class="nx">toBands</span><span class="p">(),</span>
    <span class="na">crs</span><span class="p">:</span> <span class="dl">"</span><span class="s2">EPSG:4326</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">dimensions</span><span class="p">:</span> <span class="dl">"</span><span class="s2">720x360</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">region</span><span class="p">:</span> <span class="nx">ee</span><span class="p">.</span><span class="nx">Geometry</span><span class="p">.</span><span class="nx">Rectangle</span><span class="p">([[</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span><span class="o">-</span><span class="mi">90</span><span class="p">],[</span><span class="mi">180</span><span class="p">,</span><span class="mi">90</span><span class="p">]],</span><span class="kc">null</span><span class="p">,</span><span class="kc">false</span><span class="p">),</span>
    <span class="na">fileNamePrefix</span><span class="p">:</span> <span class="nx">dataname</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="p">});</span>
</code></pre></div></div>
<p>文件大小186MB，文件格式tif，可以在matlab中使用<code class="language-plaintext highlighter-rouge">imread(filename)</code>直接读取</p>

<h2 id="算法解读">算法解读</h2>
<p>LOESS基于局部加权回归(Local Weighted Regression)原理，对散点图的某个x坐标进行局部的而非全局的加权回归，而后估计在给定x坐标上的值。
LOESS包含两个关键参数，<code class="language-plaintext highlighter-rouge">q</code>表示在给定x坐标周围参与局部多项式回归的近邻点个数，<code class="language-plaintext highlighter-rouge">d</code>表示进行局部多项式回归的多项式次数。</p>
<blockquote>
  <p>这里的x做可以取连续值，因为它只需计算与最近的采样点的距离即可得到回归权重，通过近邻点来估计当前位置点(类似KNN的思想)。</p>
</blockquote>

<p>下图演示了参数为q=7,d=1的LOESS平滑过程
<img src="https://img2023.cnblogs.com/blog/3228693/202307/3228693-20230711100809285-1628529796.gif" alt="image" />
蓝点为原始序列，红点为待估计的原始序列点，红圈为选中参与局部回归的近邻点，绿点为平滑后的估计值</p>

<h2 id="算法实现">算法实现</h2>
<p>读取tif文件并取其中一个像素点的时间序列，该序列长度为$12\times 17=204$，为17年的月采样序列</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span> <span class="o">=</span> <span class="nb">imread</span><span class="p">(</span><span class="s2">"TMP_monthly.tif"</span><span class="p">);</span>
<span class="n">y</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:),</span><span class="mi">1</span><span class="p">,[]);</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">numel</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="c1">% 这里约定x和y为行向量</span>
</code></pre></div></div>
<p>定义q和d，这里选择以7个近邻点做1次多项式(线性)回归</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">q</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="n">d</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>
<p>首先对<code class="language-plaintext highlighter-rouge">x</code>和<code class="language-plaintext highlighter-rouge">y</code>进行一个缩放和中心化(Z-Score标准化)，目的是为了在计算最小二乘解时避免数据溢出</p>
<blockquote>
  <p>实测如果不进行缩放，在x值超过120时会导致最小二乘解结果产生偏差，即便数据以64位浮点的double类型存储也无法解决，而预先进行缩放是个人实测有效的方法，不过要注意在最后进行反变换恢复成原始序列。</p>
  <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">y_mean</span> <span class="o">=</span> <span class="nb">mean</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="n">y_std</span> <span class="o">=</span> <span class="nb">std</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="n">x_mean</span> <span class="o">=</span> <span class="nb">mean</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">x_std</span> <span class="o">=</span> <span class="nb">std</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">ys</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">y_mean</span><span class="p">)/</span><span class="n">y_std</span><span class="p">;</span>
<span class="n">xs</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x_mean</span><span class="p">)/</span><span class="n">x_std</span><span class="p">;</span>
</code></pre></div>  </div>
  <p>在遍历序列中每个采样点之前声明一个数组用于存储平滑后的序列</p>
  <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">yhat</span> <span class="o">=</span> <span class="n">nan</span> <span class="o">*</span> <span class="nb">ones</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">ys</span><span class="p">));</span>
</code></pre></div>  </div>
  <p>循环体中的内容如下</p>
  <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">numel</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">xs</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="c1">% 1. 选择与xi近邻的q个y值不为nan的点</span>
    <span class="c1">% 2. 计算近邻元素权值</span>
    <span class="c1">% 3. 计算加权回归系数</span>
    <span class="c1">% 4. 计算估计值</span>
<span class="k">end</span>
</code></pre></div>  </div>
  <p>第一步的操作是为了保证时间序列存在空缺值的情况下仍能进行，LOESS的基本逻辑就是采用最近邻点进行回归估计，因此能有效填补空缺值。</p>
</blockquote>

<p>实现思路：使用<code class="language-plaintext highlighter-rouge">mink()</code>函数来取得<code class="language-plaintext highlighter-rouge">q</code>个x上距离<code class="language-plaintext highlighter-rouge">abs(xs-xi)</code>最小值点，循环判断这些点的y值是否存在nan，如果存在，则每次多取一个点(stq加1)，直到取到<code class="language-plaintext highlighter-rouge">q</code>个符合要求的近邻点。其中<code class="language-plaintext highlighter-rouge">I</code>为近邻点的索引数组，<code class="language-plaintext highlighter-rouge">B</code>为近邻点x值与$x_i$的距离数组.</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stq</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
<span class="p">[</span><span class="n">B</span><span class="p">,</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="nb">mink</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">xs</span> <span class="o">-</span> <span class="n">xi</span><span class="p">),</span><span class="n">stq</span><span class="p">);</span>
<span class="n">idxs</span> <span class="o">=</span> <span class="o">~</span><span class="nb">isnan</span><span class="p">(</span><span class="n">ys</span><span class="p">(</span><span class="n">I</span><span class="p">));</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">idxs</span><span class="p">);</span>
<span class="k">while</span> <span class="nb">numel</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">~=</span><span class="n">q</span>
    <span class="n">stq</span> <span class="o">=</span> <span class="n">stq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">[</span><span class="n">B</span><span class="p">,</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="nb">mink</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">xs</span> <span class="o">-</span> <span class="n">xi</span><span class="p">),</span><span class="n">stq</span><span class="p">);</span>
    <span class="n">idxs</span> <span class="o">=</span> <span class="o">~</span><span class="nb">isnan</span><span class="p">(</span><span class="n">ys</span><span class="p">(</span><span class="n">I</span><span class="p">));</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">idxs</span><span class="p">);</span>
<span class="k">end</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">idxs</span><span class="p">);</span>
</code></pre></div></div>
<p>上述得到的<code class="language-plaintext highlighter-rouge">B</code>中的元素，为从小到大排列的距离值，与索引序列<code class="language-plaintext highlighter-rouge">I</code>中的元素一一对应，<code class="language-plaintext highlighter-rouge">B(1)</code>是与$x_i$最近元素的x轴距离，相反<code class="language-plaintext highlighter-rouge">B(end)</code>是与$x_i$最远距离。通过<code class="language-plaintext highlighter-rouge">B</code>可以计算近邻点的权值，但首先要将<code class="language-plaintext highlighter-rouge">B</code>整体除以最远距离<code class="language-plaintext highlighter-rouge">B(end)</code>进行<code class="language-plaintext highlighter-rouge">[0,1]</code>范围归一化</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">weight</span> <span class="o">=</span> <span class="n">W</span><span class="p">(</span><span class="n">B</span><span class="p">/</span><span class="n">B</span><span class="p">(</span><span class="k">end</span><span class="p">));</span>

<span class="k">function</span> <span class="n">res</span> <span class="o">=</span> <span class="n">W</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">idx1</span> <span class="o">=</span> <span class="n">u</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">idx2</span> <span class="o">=</span> <span class="n">u</span><span class="o">&lt;</span><span class="mi">1</span> <span class="o">&amp;</span> <span class="n">u</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">idx3</span> <span class="o">=</span> <span class="n">u</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">;</span>

    <span class="n">res</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">u</span><span class="p">),</span><span class="s2">"like"</span><span class="p">,</span><span class="n">u</span><span class="p">);</span>
    <span class="n">res</span><span class="p">(</span><span class="n">idx1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">res</span><span class="p">(</span><span class="n">idx2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">u</span><span class="p">(</span><span class="n">idx2</span><span class="p">)</span><span class="o">.^</span><span class="mi">3</span><span class="p">)</span><span class="o">.^</span><span class="mi">3</span><span class="p">;</span>
    <span class="n">res</span><span class="p">(</span><span class="n">idx3</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">end</span>
</code></pre></div></div>
<p>这里的<code class="language-plaintext highlighter-rouge">W</code>函数是文献中采用的三次权函数，有的文献中采用指数
\(W(u) = \begin{cases}
(1-u^3)^3&amp;, 0\leq u\lt 1\\
0&amp;, u\geq 1
\end{cases}\)
计算得到的<code class="language-plaintext highlighter-rouge">weight</code>一般是像如下所示的以1开头逐步递减至0的序列</p>
<pre><code class="language-output">weight =
	1.0000, 0.8930, 0.8930, 0.3485, 0.3485, 0.0000, 0.0000
</code></pre>
<p>它们就是对数组<code class="language-plaintext highlighter-rouge">I</code>对应索引元素的权重，比如当前循环处理第9个元素，那么其近邻的7个点从距离由近到远的元素索引和距离分别是</p>
<pre><code class="language-output">I =
    9, 8, 10, 7, 11, 6, 12
B =
    0, 0.0169, 0.0169, 0.0339, 0.0339, 0.0508, 0.0508
</code></pre>
<p>即最近的点赋予最高的权值，而在<code class="language-plaintext highlighter-rouge">q</code>之外的点赋予$0$的权值</p>

<p>然后是计算加权回归系数，先根据多项式阶数<code class="language-plaintext highlighter-rouge">d</code>构造线性方程组$Ax=b$中的A矩阵<code class="language-plaintext highlighter-rouge">xmat</code>，它是由近邻点x值序列构造的矩阵，其第$1$列为常数列，第$2$列为$1$次项，……，第$k+1$列为$k$次项</p>

<p>$Ax=b$中的b向量<code class="language-plaintext highlighter-rouge">ymat</code>为近邻点的y值序列</p>

<p>调用matlab的<code class="language-plaintext highlighter-rouge">lsqminnorm(A,b)</code>函数计算最小范数最小二乘解，相比<code class="language-plaintext highlighter-rouge">A\b</code>具有更高的数值稳定性，同时相比<code class="language-plaintext highlighter-rouge">pinv(A)*b</code>也有更高的计算效率</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xmat</span> <span class="o">=</span> <span class="nb">ones</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">d</span>
    <span class="n">xmat</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">xs</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.^</span><span class="n">k</span><span class="p">;</span>
<span class="k">end</span>
<span class="n">ymat</span> <span class="o">=</span> <span class="n">ys</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">'</span><span class="p">;</span>
<span class="n">tp</span> <span class="o">=</span> <span class="n">xmat</span><span class="o">'</span> <span class="o">*</span> <span class="nb">diag</span><span class="p">(</span><span class="n">weight</span><span class="p">);</span>
<span class="nb">what</span> <span class="o">=</span> <span class="nb">lsqminnorm</span><span class="p">(</span><span class="n">tp</span> <span class="o">*</span> <span class="n">xmat</span><span class="p">,</span> <span class="n">tp</span> <span class="o">*</span> <span class="n">ymat</span><span class="p">);</span>
</code></pre></div></div>
<p>最后使用回归系数估计$x_i$点的$\hat y$值</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xpre</span> <span class="o">=</span> <span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">d</span>
    <span class="n">xpre</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">xi</span><span class="o">^</span><span class="n">k</span><span class="p">;</span>
<span class="k">end</span>
<span class="n">yhat</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">xpre</span> <span class="o">*</span> <span class="nb">what</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="完整代码包含可视化">完整代码(包含可视化)</h2>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clear</span><span class="p">;</span>
<span class="nb">clf</span><span class="p">;</span>

<span class="n">data</span> <span class="o">=</span> <span class="nb">imread</span><span class="p">(</span><span class="s2">"TMP_monthly.tif"</span><span class="p">);</span>
<span class="n">y</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:),</span><span class="mi">1</span><span class="p">,[]);</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">numel</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

<span class="n">q</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="n">d</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">%% LOESS(x,y,q,d)</span>
<span class="n">y_mean</span> <span class="o">=</span> <span class="nb">mean</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="n">y_std</span> <span class="o">=</span> <span class="nb">std</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="n">x_mean</span> <span class="o">=</span> <span class="nb">mean</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">x_std</span> <span class="o">=</span> <span class="nb">std</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">ys</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">y_mean</span><span class="p">)/</span><span class="n">y_std</span><span class="p">;</span>
<span class="n">xs</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x_mean</span><span class="p">)/</span><span class="n">x_std</span><span class="p">;</span>

<span class="nb">set</span><span class="p">(</span><span class="nb">gca</span><span class="p">,</span><span class="s2">"position"</span><span class="p">,[</span><span class="mf">0.05</span><span class="p">,</span><span class="mf">0.12</span><span class="p">,</span><span class="mf">0.93</span><span class="p">,</span><span class="mf">0.8</span><span class="p">])</span>
<span class="nb">set</span><span class="p">(</span><span class="nb">gcf</span><span class="p">,</span><span class="s2">"position"</span><span class="p">,</span><span class="mi">1000</span><span class="o">*</span><span class="p">[</span><span class="mf">2.6903</span>   <span class="o">-</span><span class="mf">0.2103</span>    <span class="mf">1.000</span>    <span class="mf">0.3500</span><span class="p">]);</span>
<span class="nb">set</span><span class="p">(</span><span class="nb">gcf</span><span class="p">,</span><span class="s2">"name"</span><span class="p">,</span><span class="s2">"Temperature"</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s2">"time/Month"</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s2">"temperature/K"</span><span class="p">);</span>

<span class="nb">hold</span> <span class="n">on</span><span class="p">;</span>

<span class="nb">plot</span><span class="p">(</span><span class="n">xs</span><span class="o">*</span><span class="n">x_std</span><span class="o">+</span><span class="n">x_mean</span><span class="p">,</span><span class="n">ys</span><span class="o">*</span><span class="n">y_std</span><span class="o">+</span><span class="n">y_mean</span><span class="p">,</span><span class="s1">'-o'</span><span class="p">,</span><span class="s1">'markersize'</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="s1">'MarkerFaceColor'</span><span class="p">,</span><span class="s1">'b'</span><span class="p">);</span>
<span class="nb">xlim</span><span class="p">([</span><span class="n">xs</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">x_std</span><span class="o">+</span><span class="n">x_mean</span><span class="p">,</span><span class="n">xs</span><span class="p">(</span><span class="k">end</span><span class="p">)</span><span class="o">*</span><span class="n">x_std</span><span class="o">+</span><span class="n">x_mean</span><span class="p">]);</span>
<span class="nb">title</span><span class="p">(</span><span class="nb">sprintf</span><span class="p">(</span><span class="s2">"Locally Estimated Scatterplot Smoothing (q=%d,d=%d)"</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">d</span><span class="p">));</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s2">"time/Month"</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s2">"temperature/K"</span><span class="p">);</span>

<span class="n">axlim</span> <span class="o">=</span> <span class="nb">axis</span><span class="p">;</span>

<span class="n">yhat</span> <span class="o">=</span> <span class="n">nan</span> <span class="o">*</span> <span class="nb">ones</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">ys</span><span class="p">));</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">numel</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">xs</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

    <span class="c1">% 选择q个y上不为nan的值</span>
    <span class="n">stq</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
    <span class="p">[</span><span class="n">B</span><span class="p">,</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="nb">mink</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">xs</span> <span class="o">-</span> <span class="n">xi</span><span class="p">),</span><span class="n">stq</span><span class="p">);</span>
    <span class="n">idxs</span> <span class="o">=</span> <span class="o">~</span><span class="nb">isnan</span><span class="p">(</span><span class="n">ys</span><span class="p">(</span><span class="n">I</span><span class="p">));</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">idxs</span><span class="p">);</span>
    <span class="k">while</span> <span class="nb">numel</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">~=</span><span class="n">q</span>
        <span class="n">stq</span> <span class="o">=</span> <span class="n">stq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">[</span><span class="n">B</span><span class="p">,</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="nb">mink</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">xs</span> <span class="o">-</span> <span class="n">xi</span><span class="p">),</span><span class="n">stq</span><span class="p">);</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="o">~</span><span class="nb">isnan</span><span class="p">(</span><span class="n">ys</span><span class="p">(</span><span class="n">I</span><span class="p">));</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">idxs</span><span class="p">);</span>
    <span class="k">end</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">idxs</span><span class="p">);</span>
    
    <span class="c1">% 近邻元素权重</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">W</span><span class="p">(</span><span class="n">B</span><span class="p">/</span><span class="n">B</span><span class="p">(</span><span class="k">end</span><span class="p">));</span>
    
    <span class="c1">% 最小二乘回归</span>
    <span class="n">xmat</span> <span class="o">=</span> <span class="nb">ones</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">d</span>
        <span class="n">xmat</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">xs</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.^</span><span class="n">k</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="n">ymat</span> <span class="o">=</span> <span class="n">ys</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">'</span><span class="p">;</span>
    <span class="n">tp</span> <span class="o">=</span> <span class="n">xmat</span><span class="o">'</span> <span class="o">*</span> <span class="nb">diag</span><span class="p">(</span><span class="n">weight</span><span class="p">);</span>
    <span class="nb">what</span> <span class="o">=</span> <span class="nb">lsqminnorm</span><span class="p">(</span><span class="n">tp</span> <span class="o">*</span> <span class="n">xmat</span><span class="p">,</span> <span class="n">tp</span> <span class="o">*</span> <span class="n">ymat</span><span class="p">);</span>
    <span class="n">xpre</span> <span class="o">=</span> <span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">d</span>
        <span class="n">xpre</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">xi</span><span class="o">^</span><span class="n">k</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="n">yhat</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">xpre</span> <span class="o">*</span> <span class="nb">what</span><span class="p">;</span>
    
    <span class="c1">% 绘图部分</span>
    <span class="k">if</span> <span class="nb">exist</span><span class="p">(</span><span class="s2">"selp"</span><span class="p">,</span><span class="s2">"var"</span><span class="p">)</span>
        <span class="nb">delete</span><span class="p">(</span><span class="n">selp</span><span class="p">);</span>
        <span class="nb">delete</span><span class="p">(</span><span class="n">selp1</span><span class="p">);</span>
        <span class="nb">delete</span><span class="p">(</span><span class="n">regc</span><span class="p">);</span>
    <span class="k">end</span>
    <span class="n">selp</span> <span class="o">=</span> <span class="nb">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">*</span><span class="n">x_std</span><span class="o">+</span><span class="n">x_mean</span><span class="p">,</span><span class="n">ys</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">*</span><span class="n">y_std</span><span class="o">+</span><span class="n">y_mean</span><span class="p">,</span><span class="s1">'ro'</span><span class="p">);</span>
    <span class="nb">plot</span><span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">x_std</span><span class="o">+</span><span class="n">x_mean</span><span class="p">,</span><span class="n">yhat</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">y_std</span><span class="o">+</span><span class="n">y_mean</span><span class="p">,</span><span class="s1">'g.'</span><span class="p">,</span><span class="s2">"markersize"</span><span class="p">,</span><span class="mi">16</span><span class="p">);</span>
    <span class="n">selp1</span> <span class="o">=</span> <span class="nb">plot</span><span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">x_std</span><span class="o">+</span><span class="n">x_mean</span><span class="p">,</span><span class="n">ys</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">y_std</span><span class="o">+</span><span class="n">y_mean</span><span class="p">,</span><span class="s1">'r.'</span><span class="p">,</span><span class="s2">"markersize"</span><span class="p">,</span><span class="mi">22</span><span class="p">);</span>

    <span class="c1">% 绘制回归曲线</span>
    <span class="n">xpre</span> <span class="o">=</span> <span class="nb">ones</span><span class="p">(</span><span class="nb">numel</span><span class="p">(</span><span class="n">I</span><span class="p">),</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">d</span>
        <span class="n">xpre</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">xs</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.^</span><span class="n">k</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="n">pdy</span> <span class="o">=</span> <span class="n">xpre</span> <span class="o">*</span> <span class="nb">what</span><span class="p">;</span>
    <span class="n">regc</span> <span class="o">=</span> <span class="nb">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">*</span><span class="n">x_std</span><span class="o">+</span><span class="n">x_mean</span><span class="p">,</span><span class="n">pdy</span><span class="o">*</span><span class="n">y_std</span><span class="o">+</span><span class="n">y_mean</span><span class="p">,</span><span class="s1">'k'</span><span class="p">);</span>
    <span class="nb">axis</span><span class="p">(</span><span class="n">axlim</span><span class="p">);</span>

    <span class="nb">drawnow</span><span class="p">;</span>
    <span class="c1">% pause(0.2);</span>
<span class="k">end</span>

<span class="k">function</span> <span class="n">res</span> <span class="o">=</span> <span class="n">W</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">idx1</span> <span class="o">=</span> <span class="n">u</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">idx2</span> <span class="o">=</span> <span class="n">u</span><span class="o">&lt;</span><span class="mi">1</span> <span class="o">&amp;</span> <span class="n">u</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">idx3</span> <span class="o">=</span> <span class="n">u</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">;</span>

    <span class="n">res</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">u</span><span class="p">),</span><span class="s2">"like"</span><span class="p">,</span><span class="n">u</span><span class="p">);</span>
    <span class="n">res</span><span class="p">(</span><span class="n">idx1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">res</span><span class="p">(</span><span class="n">idx2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">u</span><span class="p">(</span><span class="n">idx2</span><span class="p">)</span><span class="o">.^</span><span class="mi">3</span><span class="p">)</span><span class="o">.^</span><span class="mi">3</span><span class="p">;</span>
    <span class="n">res</span><span class="p">(</span><span class="n">idx3</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">end</span>
</code></pre></div></div>


<!-- 
  <small>tags: <em></em></small>
 -->
    </section>
  </div>
</body>

</html>