<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-08-19T18:47:11+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Windwhisper’s Blog</title><subtitle>个人博客，归纳分享所学技术</subtitle><entry><title type="html">Github Pages上的Mermaid和LaTeX渲染方案</title><link href="http://localhost:4000/2024/08/19/Github-Pages%E4%B8%8A%E7%9A%84Mermaid%E5%92%8CLaTeX%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88.html" rel="alternate" type="text/html" title="Github Pages上的Mermaid和LaTeX渲染方案" /><published>2024-08-19T00:00:00+08:00</published><updated>2024-08-19T00:00:00+08:00</updated><id>http://localhost:4000/2024/08/19/Github%20Pages%E4%B8%8A%E7%9A%84Mermaid%E5%92%8CLaTeX%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88</id><content type="html" xml:base="http://localhost:4000/2024/08/19/Github-Pages%E4%B8%8A%E7%9A%84Mermaid%E5%92%8CLaTeX%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88.html"><![CDATA[<h3 id="问题引出">问题引出</h3>

<p>2022年，GitHub主站通过workflow提供了<a href="https://github.blog/developer-skills/github/include-diagrams-markdown-files-mermaid/">mermaid支持</a>，然而该服务尚未在GitHub Pages上得到支持。</p>

<p>在原生jekyll中，可以通过插件的方式实现Mermaid和LaTeX表达式等内容的渲染，而在Github Pages中部署的jekyll默认只启用<a href="https://pages.github.com/versions/">白名单</a>中的插件，其允许使用的插件非常有限，jekyll-mermaid等插件不在其中。标准的Markdown语法也并不支持LaTeX数学公式的渲染，同样没有相关插件支持。</p>

<h3 id="解决方案">解决方案</h3>

<p>参考博客 <a href="https://juejin.cn/post/7208046833329930300">如何让 GitHub Pages 中通过 Markdown 编辑的博客支持 Mermaid？</a> 中的做法：在jekyll项目的 <code class="language-plaintext highlighter-rouge">_includes</code> 目录（如果没有就手动创建该目录）下创建一个 <code class="language-plaintext highlighter-rouge">.html</code> 文件用来加载外部CDN服务的Mermaid脚本，如 <code class="language-plaintext highlighter-rouge">mermaid_support.html</code>。内容如下</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"module"</span><span class="nt">&gt;</span>
    <span class="k">import</span> <span class="nx">mermaid</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">https://cdn.jsdelivr.net/npm/mermaid@10.0.2/+esm</span><span class="dl">'</span><span class="p">;</span>
    <span class="nx">mermaid</span><span class="p">.</span><span class="nx">initialize</span><span class="p">({</span> <span class="na">startOnLoad</span><span class="p">:</span> <span class="kc">false</span> <span class="p">});</span>
    <span class="k">await</span> <span class="nx">mermaid</span><span class="p">.</span><span class="nx">run</span><span class="p">({</span>
        <span class="na">querySelector</span><span class="p">:</span> <span class="dl">'</span><span class="s1">.language-mermaid</span><span class="dl">'</span><span class="p">,</span>
    <span class="p">});</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>
<p>此时还不能生效，需要将其加载到目标页面中。</p>

<p>jekyll加载 <code class="language-plaintext highlighter-rouge">xxx.md</code> 文件时，会读取其上方的 <code class="language-plaintext highlighter-rouge">layout: xxx</code> 配置项，如这一项不存在，则默认为 <code class="language-plaintext highlighter-rouge">layout: post</code>，即加载 <code class="language-plaintext highlighter-rouge">_layouts</code> 下的 <code class="language-plaintext highlighter-rouge">post.html</code>。</p>

<blockquote>
  <p>Github Pages的jekyll所<a href="https://pages.github.com/themes/">支持的Theme</a>中，参考它们库中的 <code class="language-plaintext highlighter-rouge">_layouts</code> 目录，这是在部署到Github Pages时默认载入且不会出现在本地的文件，按照<a href="https://jekyllrb.com/docs/themes/">jekyll官方文档-Theme</a>的描述，通过在本地创建对应的目录和同名的文件以覆盖默认文件，实现主题的定制化。</p>
</blockquote>

<p>GitHub Pages所支持的主题通常包含 <code class="language-plaintext highlighter-rouge">default.html</code> 和 <code class="language-plaintext highlighter-rouge">post.html</code> 两个layout，而在我们的 <code class="language-plaintext highlighter-rouge">XXX.md</code> 中又导入了 <code class="language-plaintext highlighter-rouge">post.html</code> ，所以三者的关系通常是</p>

<pre><code class="language-mermaid">graph BT
a[XXX.md] --&gt; b[post.html] --&gt; c[default.html]
</code></pre>

<p>从对应的jekyll主题库中复制对应的 <code class="language-plaintext highlighter-rouge">default.html</code> 下来，拷贝到自己的 <code class="language-plaintext highlighter-rouge">_layouts</code> 目录下。打开浏览可以注意到里面的head标签</p>

<p><img src="/assets/images/default.html的内容.png" alt="defalut.html的内容" /></p>

<p><code class="language-plaintext highlighter-rouge">head-custom.html</code> 其实是开放给我们自定义的头部，这样我们可以不用修改默认 <code class="language-plaintext highlighter-rouge">default.html</code>，比较优雅的做法是在 <code class="language-plaintext highlighter-rouge">_include</code> 目录下手动创建一个 <code class="language-plaintext highlighter-rouge">head_custom.html</code> 并写入以下内容</p>

<p><img src="/assets/images/head_custom.html的内容.png" alt="head_custom.html的内容" /></p>

<p>这样，当我们在 <code class="language-plaintext highlighter-rouge">xxx.md</code> 的导言区（用上下三横杠包围的区域）中定义 <code class="language-plaintext highlighter-rouge">mermaid: true</code> 时，这个渲染就会生效。这么做可以手动启停该渲染，在不需要的时候不启用可以优化页面加载速度，但要注意默认值是 <code class="language-plaintext highlighter-rouge">mermaid: false</code>，每次使用都要手动定义，嫌麻烦可以去掉首尾两行。</p>

<p>最后，<code class="language-plaintext highlighter-rouge">bundle exec jekyll serve</code> 启动即可看到mermaid被正确渲染</p>

<p>代码：</p>

<p><img src="/assets/images/mermaid代码.png" alt="mermaid代码" /></p>

<p>渲染结果：</p>

<p><img src="/assets/images/mermaid渲染结果.png" alt="mermaid渲染结果" /></p>
<blockquote>
  <p>博主这里使用了<a href="https://github.com/pages-themes/hacker">jekyll-theme-hacker</a>主题，并进行了一些css的个人定制</p>
</blockquote>

<p>同样，参考博客 <a href="https://www.cnblogs.com/tungsten106/p/17953452/github_page_add_mathjax">Github page数学公式无法正常显示解决方案(MathJax)</a> 通过类似的做法实现对LaTeX公式的渲染</p>]]></content><author><name></name></author><summary type="html"><![CDATA[问题引出]]></summary></entry><entry><title type="html">测试markdown</title><link href="http://localhost:4000/2024/08/18/%E6%B5%8B%E8%AF%95markdown.html" rel="alternate" type="text/html" title="测试markdown" /><published>2024-08-18T00:00:00+08:00</published><updated>2024-08-18T00:00:00+08:00</updated><id>http://localhost:4000/2024/08/18/%E6%B5%8B%E8%AF%95markdown</id><content type="html" xml:base="http://localhost:4000/2024/08/18/%E6%B5%8B%E8%AF%95markdown.html"><![CDATA[<h3 id="列表元素">列表元素</h3>
<ol>
  <li>有序列表1</li>
  <li>有序列表2
    <ol>
      <li>有序列表2.1</li>
      <li>有序列表2.2</li>
    </ol>
  </li>
  <li>有序列表3</li>
</ol>

<ul>
  <li>无序列表1</li>
  <li>无序列表2
    <ul>
      <li>无序列表2.1</li>
      <li>无序列表2.2</li>
    </ul>
  </li>
  <li>无序列表3</li>
</ul>

<h3 id="引用">引用</h3>
<blockquote>
  <p>“When you gaze into the abyss, the abyss also gazes into you.”  by <em>Friedrich Wilhelm Nietzsche</em></p>
</blockquote>

<h3 id="代码块">代码块</h3>

<h4 id="c语言">C语言</h4>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Hello World!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="matlab脚本">matlab脚本</h4>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="nb">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="s2">"r.-"</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="python脚本">python脚本</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="n">__main__</span><span class="p">:</span>
  <span class="k">print</span><span class="p">(</span><span class="s">"Hello World"</span><span class="p">)</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">21</span><span class="p">)</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>
</code></pre></div></div>

<h3 id="数学公式">数学公式</h3>

<h4 id="行内公式">行内公式</h4>

<p>$ \sum_{i=0}^N f(x_i) \Delta x $</p>

<h4 id="行间公式">行间公式</h4>

\[F(\omega) = \mathcal F[f(t)] = \int_{-\infty}^{\infty} f(t)\mathrm e^{-i \omega t}\, \mathrm d t\]

<h3 id="导入图片">导入图片</h3>

<p>网络图片：
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e6/VirtualBox_Kali_Linux_29_03_2022_11_10_35.png/550px-VirtualBox_Kali_Linux_29_03_2022_11_10_35.png" alt="图片" /></p>

<p>本地图片：
<img src="/assets/images/test_image.png" alt="本地图片" /></p>

<h3 id="mermaid">mermaid</h3>

<h4 id="饼图">饼图</h4>
<pre><code class="language-mermaid">pie title Pets adopted by volunteers
  "Dogs" : 386
  "Cats" : 85
  "Rats" : 35
</code></pre>

<h4 id="结构图">结构图</h4>
<pre><code class="language-mermaid">    graph TB
    1(a)--&gt;2(b)--&gt;3(c)--&gt;4(X)
    3(c)--&gt;5(Y)
    1(a)--&gt;6(Z)
    2(b)--&gt;7(W)
</code></pre>

<h4 id="流程图">流程图</h4>
<pre><code class="language-mermaid">flowchart TD
  A[Start] --&gt; B{Is it?}
  B --&gt;|Yes| C[OK]
  C --&gt; D[Rethink]
  D --&gt; B
  B ----&gt;|No| E[End]
</code></pre>]]></content><author><name></name></author><summary type="html"><![CDATA[列表元素 有序列表1 有序列表2 有序列表2.1 有序列表2.2 有序列表3]]></summary></entry><entry><title type="html">二叉树平衡调整</title><link href="http://localhost:4000/2024/08/17/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B0%83%E6%95%B4.html" rel="alternate" type="text/html" title="二叉树平衡调整" /><published>2024-08-17T00:00:00+08:00</published><updated>2024-08-17T00:00:00+08:00</updated><id>http://localhost:4000/2024/08/17/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B0%83%E6%95%B4</id><content type="html" xml:base="http://localhost:4000/2024/08/17/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B0%83%E6%95%B4.html"><![CDATA[<h2 id="不平衡二叉树的4种基本情形">不平衡二叉树的4种基本情形</h2>
<ul>
  <li><a href="#不平衡二叉树的4种基本情形">不平衡二叉树的4种基本情形</a>
    <ul>
      <li><a href="#ll型">LL型</a></li>
      <li><a href="#rr型">RR型</a></li>
      <li><a href="#lr型">LR型</a></li>
      <li><a href="#rl型">RL型</a></li>
    </ul>
  </li>
</ul>

<h3 id="ll型">LL型</h3>

<pre><code class="language-mermaid">graph TB
root--&gt;a--&gt;b--&gt;c--&gt;Z
a--&gt;X
b--&gt;Y
c--&gt;W
</code></pre>

<p>变换步骤：<code class="language-plaintext highlighter-rouge">a</code> 相对 <code class="language-plaintext highlighter-rouge">b</code> 做 <code class="language-plaintext highlighter-rouge">右旋</code> 变换</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">a-&gt;left = b-&gt;right</code></li>
  <li><code class="language-plaintext highlighter-rouge">b-&gt;right = a</code></li>
  <li><code class="language-plaintext highlighter-rouge">root-&gt;next = b</code></li>
</ol>

<pre><code class="language-mermaid">graph TB
root--&gt;b--&gt;c--&gt;Z
c--&gt;W
b--&gt;a--&gt;Y
a--&gt;X
</code></pre>

<h3 id="rr型">RR型</h3>

<pre><code class="language-mermaid">graph TB
root--&gt;a--&gt;X
a--&gt;b--&gt;Y
b--&gt;c--&gt;Z
c--&gt;W
</code></pre>

<p>变换步骤：<code class="language-plaintext highlighter-rouge">a</code> 相对 <code class="language-plaintext highlighter-rouge">b</code> 做 <code class="language-plaintext highlighter-rouge">左旋</code> 变换</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">a-&gt;right = b-&gt;left</code></li>
  <li><code class="language-plaintext highlighter-rouge">b-&gt;left = a</code></li>
  <li><code class="language-plaintext highlighter-rouge">root-&gt;next = b</code></li>
</ol>

<pre><code class="language-mermaid">graph TB
root--&gt;b--&gt;a--&gt;X
a--&gt;Y
b--&gt;c--&gt;Z
c--&gt;W
</code></pre>

<h3 id="lr型">LR型</h3>

<pre><code class="language-mermaid">graph TB
root--&gt;a--&gt;b--&gt;Y
a--&gt;X
b--&gt;c--&gt;Z
c--&gt;W
</code></pre>

<p>分步变换：</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">b</code> 相对 <code class="language-plaintext highlighter-rouge">c</code> 做 <code class="language-plaintext highlighter-rouge">左旋</code> 变换</li>
  <li><code class="language-plaintext highlighter-rouge">a</code> 相对 <code class="language-plaintext highlighter-rouge">c</code> 做 <code class="language-plaintext highlighter-rouge">右旋</code> 变换</li>
</ol>

<pre><code class="language-mermaid">graph TB
root--&gt;a--&gt;c--&gt;b--&gt;Y
a--&gt;X
b--&gt;Z
c--&gt;W
</code></pre>

<pre><code class="language-mermaid">graph TB
root--&gt;c--&gt;b--&gt;Y
b--&gt;Z
c--&gt;a--&gt;W
a--&gt;X
</code></pre>

<p>一步到位法:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">b-&gt;right = c-&gt;left</code></li>
  <li><code class="language-plaintext highlighter-rouge">c-&gt;left = b</code></li>
  <li><code class="language-plaintext highlighter-rouge">a-&gt;left = c-&gt;right</code></li>
  <li><code class="language-plaintext highlighter-rouge">c-&gt;right = a</code></li>
  <li><code class="language-plaintext highlighter-rouge">root-&gt;next = c</code></li>
</ol>

<h3 id="rl型">RL型</h3>

<pre><code class="language-mermaid">graph TB
root--&gt;a--&gt;X
a--&gt;b--&gt;c--&gt;Z
b--&gt;Y
c--&gt;W
</code></pre>

<p>分步变换：</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">b</code> 相对 <code class="language-plaintext highlighter-rouge">c</code> 做 <code class="language-plaintext highlighter-rouge">右旋</code> 变换</li>
  <li><code class="language-plaintext highlighter-rouge">a</code> 相对 <code class="language-plaintext highlighter-rouge">c</code> 做 <code class="language-plaintext highlighter-rouge">左旋</code> 变换</li>
</ol>

<pre><code class="language-mermaid">graph TB
root--&gt;a--&gt;X
a--&gt;c--&gt;Z
c--&gt;b--&gt;W
b--&gt;Y
</code></pre>

<pre><code class="language-mermaid">graph TB
root--&gt;c--&gt;a--&gt;X
a--&gt;Z
c--&gt;b--&gt;W
b--&gt;Y
</code></pre>

<p>一步到位法：</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">a-&gt;right = c-&gt;left</code></li>
  <li><code class="language-plaintext highlighter-rouge">c-&gt;left = a</code></li>
  <li><code class="language-plaintext highlighter-rouge">b-&gt;left = c-&gt;right</code></li>
  <li><code class="language-plaintext highlighter-rouge">c-&gt;right = b</code></li>
  <li><code class="language-plaintext highlighter-rouge">root-&gt;next = c</code></li>
</ol>]]></content><author><name></name></author><summary type="html"><![CDATA[不平衡二叉树的4种基本情形 不平衡二叉树的4种基本情形 LL型 RR型 LR型 RL型]]></summary></entry><entry><title type="html">LOESS：局部散点图平滑(Locally Estimated Scatterplot Smoothing) matlab实现</title><link href="http://localhost:4000/2023/07/11/LOESS-%E5%B1%80%E9%83%A8%E6%95%A3%E7%82%B9%E5%9B%BE%E5%B9%B3%E6%BB%91(Locally-Estimated-Scatterplot-Smoothing)-matlab%E5%AE%9E%E7%8E%B0.html" rel="alternate" type="text/html" title="LOESS：局部散点图平滑(Locally Estimated Scatterplot Smoothing) matlab实现" /><published>2023-07-11T00:00:00+08:00</published><updated>2023-07-11T00:00:00+08:00</updated><id>http://localhost:4000/2023/07/11/LOESS%EF%BC%9A%E5%B1%80%E9%83%A8%E6%95%A3%E7%82%B9%E5%9B%BE%E5%B9%B3%E6%BB%91(Locally%20Estimated%20Scatterplot%20Smoothing)%20matlab%E5%AE%9E%E7%8E%B0</id><content type="html" xml:base="http://localhost:4000/2023/07/11/LOESS-%E5%B1%80%E9%83%A8%E6%95%A3%E7%82%B9%E5%9B%BE%E5%B9%B3%E6%BB%91(Locally-Estimated-Scatterplot-Smoothing)-matlab%E5%AE%9E%E7%8E%B0.html"><![CDATA[<h2 id="前言">前言</h2>
<p>最近在学习时间序列预测，需要使用STL算法对时间序列进行季节性趋势分离，而其中使用到一个称作LOESS的平滑算法。
本文是对1990年一篇有关时间序列分析论文中提及的LOESS算法的部分解读，并基于matlab实现</p>

<p><a href="https://scholar.google.co.jp/scholar_url?url=http://www.nniiem.ru/file/news/2016/stl-statistical-model.pdf&amp;hl=zh-CN&amp;sa=X&amp;ei=oqOsZNqyCaSK6rQPhqKGiAE&amp;scisig=ABFrs3yOkcuHV4Q4StOGq9vmlX1X&amp;oi=scholarr">STL: A Seasonal-Trend Decomposition Procedure Based on Loess</a></p>

<h2 id="数据来源">数据来源</h2>
<p>在google earth engine上获取2002年到2018年共17年的全球温度月(平均)数据，空间分辨率0.5°，时间分辨率1月
(获取数据需要特殊网络环境)</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d2</span> <span class="o">=</span> <span class="nx">ee</span><span class="p">.</span><span class="nx">ImageCollection</span><span class="p">(</span><span class="dl">"</span><span class="s2">ECMWF/ERA5/DAILY</span><span class="dl">"</span><span class="p">).</span><span class="nx">filterDate</span><span class="p">(</span><span class="dl">"</span><span class="s2">2002-01-01</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">2019-01-01</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">start_t</span> <span class="o">=</span> <span class="nx">ee</span><span class="p">.</span><span class="nb">Date</span><span class="p">(</span><span class="dl">"</span><span class="s2">2002-01-01</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">sq</span> <span class="o">=</span> <span class="nx">ee</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nx">sequence</span><span class="p">({</span>
    <span class="na">start</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="na">end</span><span class="p">:</span> <span class="mi">12</span><span class="o">*</span><span class="mi">17</span>
<span class="p">});</span>
<span class="kd">var</span> <span class="nx">d2</span> <span class="o">=</span> <span class="nx">ee</span><span class="p">.</span><span class="nx">ImageCollection</span><span class="p">(</span><span class="nx">sq</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">m</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">start_d</span> <span class="o">=</span> <span class="nx">start_t</span><span class="p">.</span><span class="nx">advance</span><span class="p">(</span><span class="nx">ee</span><span class="p">.</span><span class="nb">Number</span><span class="p">(</span><span class="nx">m</span><span class="p">).</span><span class="nx">subtract</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="dl">"</span><span class="s2">month</span><span class="dl">"</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">end_d</span> <span class="o">=</span> <span class="nx">start_d</span><span class="p">.</span><span class="nx">advance</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="dl">"</span><span class="s2">month</span><span class="dl">"</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">new_d</span> <span class="o">=</span> <span class="nx">d2</span><span class="p">.</span><span class="nx">filterDate</span><span class="p">(</span><span class="nx">start_d</span><span class="p">,</span><span class="nx">end_d</span><span class="p">).</span><span class="nx">mean</span><span class="p">()</span>
        <span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">"</span><span class="s2">system:time_start</span><span class="dl">"</span><span class="p">,</span><span class="nx">start_d</span><span class="p">.</span><span class="nx">millis</span><span class="p">());</span>
    <span class="k">return</span> <span class="nx">new_d</span><span class="p">;</span>
<span class="p">}));</span>
<span class="kd">var</span> <span class="nx">TMP</span> <span class="o">=</span> <span class="nx">d2</span><span class="p">.</span><span class="nx">select</span><span class="p">(</span><span class="dl">"</span><span class="s2">mean_2m_air_temperature</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">Export</span><span class="p">.</span><span class="nx">image</span><span class="p">.</span><span class="nx">toDrive</span><span class="p">({</span>
    <span class="na">image</span><span class="p">:</span> <span class="nx">TMP</span><span class="p">.</span><span class="nx">toBands</span><span class="p">(),</span>
    <span class="na">crs</span><span class="p">:</span> <span class="dl">"</span><span class="s2">EPSG:4326</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">dimensions</span><span class="p">:</span> <span class="dl">"</span><span class="s2">720x360</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">region</span><span class="p">:</span> <span class="nx">ee</span><span class="p">.</span><span class="nx">Geometry</span><span class="p">.</span><span class="nx">Rectangle</span><span class="p">([[</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span><span class="o">-</span><span class="mi">90</span><span class="p">],[</span><span class="mi">180</span><span class="p">,</span><span class="mi">90</span><span class="p">]],</span><span class="kc">null</span><span class="p">,</span><span class="kc">false</span><span class="p">),</span>
    <span class="na">fileNamePrefix</span><span class="p">:</span> <span class="nx">dataname</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="p">});</span>
</code></pre></div></div>
<p>文件大小186MB，文件格式tif，可以在matlab中使用<code class="language-plaintext highlighter-rouge">imread(filename)</code>直接读取</p>

<h2 id="算法解读">算法解读</h2>
<p>LOESS基于局部加权回归(Local Weighted Regression)原理，对散点图的某个x坐标进行局部的而非全局的加权回归，而后估计在给定x坐标上的值。
LOESS包含两个关键参数，<code class="language-plaintext highlighter-rouge">q</code>表示在给定x坐标周围参与局部多项式回归的近邻点个数，<code class="language-plaintext highlighter-rouge">d</code>表示进行局部多项式回归的多项式次数。</p>
<blockquote>
  <p>这里的x做可以取连续值，因为它只需计算与最近的采样点的距离即可得到回归权重，通过近邻点来估计当前位置点(类似KNN的思想)。</p>
</blockquote>

<p>下图演示了参数为q=7,d=1的LOESS平滑过程
<img src="https://img2023.cnblogs.com/blog/3228693/202307/3228693-20230711100809285-1628529796.gif" alt="image" />
蓝点为原始序列，红点为待估计的原始序列点，红圈为选中参与局部回归的近邻点，绿点为平滑后的估计值</p>

<h2 id="算法实现">算法实现</h2>
<p>读取tif文件并取其中一个像素点的时间序列，该序列长度为$12\times 17=204$，为17年的月采样序列</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span> <span class="o">=</span> <span class="nb">imread</span><span class="p">(</span><span class="s2">"TMP_monthly.tif"</span><span class="p">);</span>
<span class="n">y</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:),</span><span class="mi">1</span><span class="p">,[]);</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">numel</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="c1">% 这里约定x和y为行向量</span>
</code></pre></div></div>
<p>定义q和d，这里选择以7个近邻点做1次多项式(线性)回归</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">q</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="n">d</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>
<p>首先对<code class="language-plaintext highlighter-rouge">x</code>和<code class="language-plaintext highlighter-rouge">y</code>进行一个缩放和中心化(Z-Score标准化)，目的是为了在计算最小二乘解时避免数据溢出</p>
<blockquote>
  <p>实测如果不进行缩放，在x值超过120时会导致最小二乘解结果产生偏差，即便数据以64位浮点的double类型存储也无法解决，而预先进行缩放是个人实测有效的方法，不过要注意在最后进行反变换恢复成原始序列。</p>
  <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">y_mean</span> <span class="o">=</span> <span class="nb">mean</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="n">y_std</span> <span class="o">=</span> <span class="nb">std</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="n">x_mean</span> <span class="o">=</span> <span class="nb">mean</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">x_std</span> <span class="o">=</span> <span class="nb">std</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">ys</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">y_mean</span><span class="p">)/</span><span class="n">y_std</span><span class="p">;</span>
<span class="n">xs</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x_mean</span><span class="p">)/</span><span class="n">x_std</span><span class="p">;</span>
</code></pre></div>  </div>
  <p>在遍历序列中每个采样点之前声明一个数组用于存储平滑后的序列</p>
  <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">yhat</span> <span class="o">=</span> <span class="n">nan</span> <span class="o">*</span> <span class="nb">ones</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">ys</span><span class="p">));</span>
</code></pre></div>  </div>
  <p>循环体中的内容如下</p>
  <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">numel</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">xs</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="c1">% 1. 选择与xi近邻的q个y值不为nan的点</span>
    <span class="c1">% 2. 计算近邻元素权值</span>
    <span class="c1">% 3. 计算加权回归系数</span>
    <span class="c1">% 4. 计算估计值</span>
<span class="k">end</span>
</code></pre></div>  </div>
  <p>第一步的操作是为了保证时间序列存在空缺值的情况下仍能进行，LOESS的基本逻辑就是采用最近邻点进行回归估计，因此能有效填补空缺值。</p>
</blockquote>

<p>实现思路：使用<code class="language-plaintext highlighter-rouge">mink()</code>函数来取得<code class="language-plaintext highlighter-rouge">q</code>个x上距离<code class="language-plaintext highlighter-rouge">abs(xs-xi)</code>最小值点，循环判断这些点的y值是否存在nan，如果存在，则每次多取一个点(stq加1)，直到取到<code class="language-plaintext highlighter-rouge">q</code>个符合要求的近邻点。其中<code class="language-plaintext highlighter-rouge">I</code>为近邻点的索引数组，<code class="language-plaintext highlighter-rouge">B</code>为近邻点x值与$x_i$的距离数组.</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stq</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
<span class="p">[</span><span class="n">B</span><span class="p">,</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="nb">mink</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">xs</span> <span class="o">-</span> <span class="n">xi</span><span class="p">),</span><span class="n">stq</span><span class="p">);</span>
<span class="n">idxs</span> <span class="o">=</span> <span class="o">~</span><span class="nb">isnan</span><span class="p">(</span><span class="n">ys</span><span class="p">(</span><span class="n">I</span><span class="p">));</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">idxs</span><span class="p">);</span>
<span class="k">while</span> <span class="nb">numel</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">~=</span><span class="n">q</span>
    <span class="n">stq</span> <span class="o">=</span> <span class="n">stq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">[</span><span class="n">B</span><span class="p">,</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="nb">mink</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">xs</span> <span class="o">-</span> <span class="n">xi</span><span class="p">),</span><span class="n">stq</span><span class="p">);</span>
    <span class="n">idxs</span> <span class="o">=</span> <span class="o">~</span><span class="nb">isnan</span><span class="p">(</span><span class="n">ys</span><span class="p">(</span><span class="n">I</span><span class="p">));</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">idxs</span><span class="p">);</span>
<span class="k">end</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">idxs</span><span class="p">);</span>
</code></pre></div></div>
<p>上述得到的<code class="language-plaintext highlighter-rouge">B</code>中的元素，为从小到大排列的距离值，与索引序列<code class="language-plaintext highlighter-rouge">I</code>中的元素一一对应，<code class="language-plaintext highlighter-rouge">B(1)</code>是与$x_i$最近元素的x轴距离，相反<code class="language-plaintext highlighter-rouge">B(end)</code>是与$x_i$最远距离。通过<code class="language-plaintext highlighter-rouge">B</code>可以计算近邻点的权值，但首先要将<code class="language-plaintext highlighter-rouge">B</code>整体除以最远距离<code class="language-plaintext highlighter-rouge">B(end)</code>进行<code class="language-plaintext highlighter-rouge">[0,1]</code>范围归一化</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">weight</span> <span class="o">=</span> <span class="n">W</span><span class="p">(</span><span class="n">B</span><span class="p">/</span><span class="n">B</span><span class="p">(</span><span class="k">end</span><span class="p">));</span>

<span class="k">function</span> <span class="n">res</span> <span class="o">=</span> <span class="n">W</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">idx1</span> <span class="o">=</span> <span class="n">u</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">idx2</span> <span class="o">=</span> <span class="n">u</span><span class="o">&lt;</span><span class="mi">1</span> <span class="o">&amp;</span> <span class="n">u</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">idx3</span> <span class="o">=</span> <span class="n">u</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">;</span>

    <span class="n">res</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">u</span><span class="p">),</span><span class="s2">"like"</span><span class="p">,</span><span class="n">u</span><span class="p">);</span>
    <span class="n">res</span><span class="p">(</span><span class="n">idx1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">res</span><span class="p">(</span><span class="n">idx2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">u</span><span class="p">(</span><span class="n">idx2</span><span class="p">)</span><span class="o">.^</span><span class="mi">3</span><span class="p">)</span><span class="o">.^</span><span class="mi">3</span><span class="p">;</span>
    <span class="n">res</span><span class="p">(</span><span class="n">idx3</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">end</span>
</code></pre></div></div>
<p>这里的<code class="language-plaintext highlighter-rouge">W</code>函数是文献中采用的三次权函数，有的文献中采用指数
\(W(u) = \begin{cases}
(1-u^3)^3&amp;, 0\leq u\lt 1\\
0&amp;, u\geq 1
\end{cases}\)
计算得到的<code class="language-plaintext highlighter-rouge">weight</code>一般是像如下所示的以1开头逐步递减至0的序列</p>
<pre><code class="language-output">weight =
	1.0000, 0.8930, 0.8930, 0.3485, 0.3485, 0.0000, 0.0000
</code></pre>
<p>它们就是对数组<code class="language-plaintext highlighter-rouge">I</code>对应索引元素的权重，比如当前循环处理第9个元素，那么其近邻的7个点从距离由近到远的元素索引和距离分别是</p>
<pre><code class="language-output">I =
    9, 8, 10, 7, 11, 6, 12
B =
    0, 0.0169, 0.0169, 0.0339, 0.0339, 0.0508, 0.0508
</code></pre>
<p>即最近的点赋予最高的权值，而在<code class="language-plaintext highlighter-rouge">q</code>之外的点赋予$0$的权值</p>

<p>然后是计算加权回归系数，先根据多项式阶数<code class="language-plaintext highlighter-rouge">d</code>构造线性方程组$Ax=b$中的A矩阵<code class="language-plaintext highlighter-rouge">xmat</code>，它是由近邻点x值序列构造的矩阵，其第$1$列为常数列，第$2$列为$1$次项，……，第$k+1$列为$k$次项</p>

<p>$Ax=b$中的b向量<code class="language-plaintext highlighter-rouge">ymat</code>为近邻点的y值序列</p>

<p>调用matlab的<code class="language-plaintext highlighter-rouge">lsqminnorm(A,b)</code>函数计算最小范数最小二乘解，相比<code class="language-plaintext highlighter-rouge">A\b</code>具有更高的数值稳定性，同时相比<code class="language-plaintext highlighter-rouge">pinv(A)*b</code>也有更高的计算效率</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xmat</span> <span class="o">=</span> <span class="nb">ones</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">d</span>
    <span class="n">xmat</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">xs</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.^</span><span class="n">k</span><span class="p">;</span>
<span class="k">end</span>
<span class="n">ymat</span> <span class="o">=</span> <span class="n">ys</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">'</span><span class="p">;</span>
<span class="n">tp</span> <span class="o">=</span> <span class="n">xmat</span><span class="o">'</span> <span class="o">*</span> <span class="nb">diag</span><span class="p">(</span><span class="n">weight</span><span class="p">);</span>
<span class="nb">what</span> <span class="o">=</span> <span class="nb">lsqminnorm</span><span class="p">(</span><span class="n">tp</span> <span class="o">*</span> <span class="n">xmat</span><span class="p">,</span> <span class="n">tp</span> <span class="o">*</span> <span class="n">ymat</span><span class="p">);</span>
</code></pre></div></div>
<p>最后使用回归系数估计$x_i$点的$\hat y$值</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xpre</span> <span class="o">=</span> <span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">d</span>
    <span class="n">xpre</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">xi</span><span class="o">^</span><span class="n">k</span><span class="p">;</span>
<span class="k">end</span>
<span class="n">yhat</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">xpre</span> <span class="o">*</span> <span class="nb">what</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="完整代码包含可视化">完整代码(包含可视化)</h2>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clear</span><span class="p">;</span>
<span class="nb">clf</span><span class="p">;</span>

<span class="n">data</span> <span class="o">=</span> <span class="nb">imread</span><span class="p">(</span><span class="s2">"TMP_monthly.tif"</span><span class="p">);</span>
<span class="n">y</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:),</span><span class="mi">1</span><span class="p">,[]);</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">numel</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

<span class="n">q</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="n">d</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">%% LOESS(x,y,q,d)</span>
<span class="n">y_mean</span> <span class="o">=</span> <span class="nb">mean</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="n">y_std</span> <span class="o">=</span> <span class="nb">std</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="n">x_mean</span> <span class="o">=</span> <span class="nb">mean</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">x_std</span> <span class="o">=</span> <span class="nb">std</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">ys</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">y_mean</span><span class="p">)/</span><span class="n">y_std</span><span class="p">;</span>
<span class="n">xs</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x_mean</span><span class="p">)/</span><span class="n">x_std</span><span class="p">;</span>

<span class="nb">set</span><span class="p">(</span><span class="nb">gca</span><span class="p">,</span><span class="s2">"position"</span><span class="p">,[</span><span class="mf">0.05</span><span class="p">,</span><span class="mf">0.12</span><span class="p">,</span><span class="mf">0.93</span><span class="p">,</span><span class="mf">0.8</span><span class="p">])</span>
<span class="nb">set</span><span class="p">(</span><span class="nb">gcf</span><span class="p">,</span><span class="s2">"position"</span><span class="p">,</span><span class="mi">1000</span><span class="o">*</span><span class="p">[</span><span class="mf">2.6903</span>   <span class="o">-</span><span class="mf">0.2103</span>    <span class="mf">1.000</span>    <span class="mf">0.3500</span><span class="p">]);</span>
<span class="nb">set</span><span class="p">(</span><span class="nb">gcf</span><span class="p">,</span><span class="s2">"name"</span><span class="p">,</span><span class="s2">"Temperature"</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s2">"time/Month"</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s2">"temperature/K"</span><span class="p">);</span>

<span class="nb">hold</span> <span class="n">on</span><span class="p">;</span>

<span class="nb">plot</span><span class="p">(</span><span class="n">xs</span><span class="o">*</span><span class="n">x_std</span><span class="o">+</span><span class="n">x_mean</span><span class="p">,</span><span class="n">ys</span><span class="o">*</span><span class="n">y_std</span><span class="o">+</span><span class="n">y_mean</span><span class="p">,</span><span class="s1">'-o'</span><span class="p">,</span><span class="s1">'markersize'</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="s1">'MarkerFaceColor'</span><span class="p">,</span><span class="s1">'b'</span><span class="p">);</span>
<span class="nb">xlim</span><span class="p">([</span><span class="n">xs</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">x_std</span><span class="o">+</span><span class="n">x_mean</span><span class="p">,</span><span class="n">xs</span><span class="p">(</span><span class="k">end</span><span class="p">)</span><span class="o">*</span><span class="n">x_std</span><span class="o">+</span><span class="n">x_mean</span><span class="p">]);</span>
<span class="nb">title</span><span class="p">(</span><span class="nb">sprintf</span><span class="p">(</span><span class="s2">"Locally Estimated Scatterplot Smoothing (q=%d,d=%d)"</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">d</span><span class="p">));</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s2">"time/Month"</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s2">"temperature/K"</span><span class="p">);</span>

<span class="n">axlim</span> <span class="o">=</span> <span class="nb">axis</span><span class="p">;</span>

<span class="n">yhat</span> <span class="o">=</span> <span class="n">nan</span> <span class="o">*</span> <span class="nb">ones</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">ys</span><span class="p">));</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">numel</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">xs</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

    <span class="c1">% 选择q个y上不为nan的值</span>
    <span class="n">stq</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
    <span class="p">[</span><span class="n">B</span><span class="p">,</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="nb">mink</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">xs</span> <span class="o">-</span> <span class="n">xi</span><span class="p">),</span><span class="n">stq</span><span class="p">);</span>
    <span class="n">idxs</span> <span class="o">=</span> <span class="o">~</span><span class="nb">isnan</span><span class="p">(</span><span class="n">ys</span><span class="p">(</span><span class="n">I</span><span class="p">));</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">idxs</span><span class="p">);</span>
    <span class="k">while</span> <span class="nb">numel</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">~=</span><span class="n">q</span>
        <span class="n">stq</span> <span class="o">=</span> <span class="n">stq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">[</span><span class="n">B</span><span class="p">,</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="nb">mink</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">xs</span> <span class="o">-</span> <span class="n">xi</span><span class="p">),</span><span class="n">stq</span><span class="p">);</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="o">~</span><span class="nb">isnan</span><span class="p">(</span><span class="n">ys</span><span class="p">(</span><span class="n">I</span><span class="p">));</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">idxs</span><span class="p">);</span>
    <span class="k">end</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">idxs</span><span class="p">);</span>
    
    <span class="c1">% 近邻元素权重</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">W</span><span class="p">(</span><span class="n">B</span><span class="p">/</span><span class="n">B</span><span class="p">(</span><span class="k">end</span><span class="p">));</span>
    
    <span class="c1">% 最小二乘回归</span>
    <span class="n">xmat</span> <span class="o">=</span> <span class="nb">ones</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">d</span>
        <span class="n">xmat</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">xs</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.^</span><span class="n">k</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="n">ymat</span> <span class="o">=</span> <span class="n">ys</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">'</span><span class="p">;</span>
    <span class="n">tp</span> <span class="o">=</span> <span class="n">xmat</span><span class="o">'</span> <span class="o">*</span> <span class="nb">diag</span><span class="p">(</span><span class="n">weight</span><span class="p">);</span>
    <span class="nb">what</span> <span class="o">=</span> <span class="nb">lsqminnorm</span><span class="p">(</span><span class="n">tp</span> <span class="o">*</span> <span class="n">xmat</span><span class="p">,</span> <span class="n">tp</span> <span class="o">*</span> <span class="n">ymat</span><span class="p">);</span>
    <span class="n">xpre</span> <span class="o">=</span> <span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">d</span>
        <span class="n">xpre</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">xi</span><span class="o">^</span><span class="n">k</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="n">yhat</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">xpre</span> <span class="o">*</span> <span class="nb">what</span><span class="p">;</span>
    
    <span class="c1">% 绘图部分</span>
    <span class="k">if</span> <span class="nb">exist</span><span class="p">(</span><span class="s2">"selp"</span><span class="p">,</span><span class="s2">"var"</span><span class="p">)</span>
        <span class="nb">delete</span><span class="p">(</span><span class="n">selp</span><span class="p">);</span>
        <span class="nb">delete</span><span class="p">(</span><span class="n">selp1</span><span class="p">);</span>
        <span class="nb">delete</span><span class="p">(</span><span class="n">regc</span><span class="p">);</span>
    <span class="k">end</span>
    <span class="n">selp</span> <span class="o">=</span> <span class="nb">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">*</span><span class="n">x_std</span><span class="o">+</span><span class="n">x_mean</span><span class="p">,</span><span class="n">ys</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">*</span><span class="n">y_std</span><span class="o">+</span><span class="n">y_mean</span><span class="p">,</span><span class="s1">'ro'</span><span class="p">);</span>
    <span class="nb">plot</span><span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">x_std</span><span class="o">+</span><span class="n">x_mean</span><span class="p">,</span><span class="n">yhat</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">y_std</span><span class="o">+</span><span class="n">y_mean</span><span class="p">,</span><span class="s1">'g.'</span><span class="p">,</span><span class="s2">"markersize"</span><span class="p">,</span><span class="mi">16</span><span class="p">);</span>
    <span class="n">selp1</span> <span class="o">=</span> <span class="nb">plot</span><span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">x_std</span><span class="o">+</span><span class="n">x_mean</span><span class="p">,</span><span class="n">ys</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">y_std</span><span class="o">+</span><span class="n">y_mean</span><span class="p">,</span><span class="s1">'r.'</span><span class="p">,</span><span class="s2">"markersize"</span><span class="p">,</span><span class="mi">22</span><span class="p">);</span>

    <span class="c1">% 绘制回归曲线</span>
    <span class="n">xpre</span> <span class="o">=</span> <span class="nb">ones</span><span class="p">(</span><span class="nb">numel</span><span class="p">(</span><span class="n">I</span><span class="p">),</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">d</span>
        <span class="n">xpre</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">xs</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.^</span><span class="n">k</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="n">pdy</span> <span class="o">=</span> <span class="n">xpre</span> <span class="o">*</span> <span class="nb">what</span><span class="p">;</span>
    <span class="n">regc</span> <span class="o">=</span> <span class="nb">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">*</span><span class="n">x_std</span><span class="o">+</span><span class="n">x_mean</span><span class="p">,</span><span class="n">pdy</span><span class="o">*</span><span class="n">y_std</span><span class="o">+</span><span class="n">y_mean</span><span class="p">,</span><span class="s1">'k'</span><span class="p">);</span>
    <span class="nb">axis</span><span class="p">(</span><span class="n">axlim</span><span class="p">);</span>

    <span class="nb">drawnow</span><span class="p">;</span>
    <span class="c1">% pause(0.2);</span>
<span class="k">end</span>

<span class="k">function</span> <span class="n">res</span> <span class="o">=</span> <span class="n">W</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">idx1</span> <span class="o">=</span> <span class="n">u</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">idx2</span> <span class="o">=</span> <span class="n">u</span><span class="o">&lt;</span><span class="mi">1</span> <span class="o">&amp;</span> <span class="n">u</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">idx3</span> <span class="o">=</span> <span class="n">u</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">;</span>

    <span class="n">res</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">u</span><span class="p">),</span><span class="s2">"like"</span><span class="p">,</span><span class="n">u</span><span class="p">);</span>
    <span class="n">res</span><span class="p">(</span><span class="n">idx1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">res</span><span class="p">(</span><span class="n">idx2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">u</span><span class="p">(</span><span class="n">idx2</span><span class="p">)</span><span class="o">.^</span><span class="mi">3</span><span class="p">)</span><span class="o">.^</span><span class="mi">3</span><span class="p">;</span>
    <span class="n">res</span><span class="p">(</span><span class="n">idx3</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">end</span>
</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[前言 最近在学习时间序列预测，需要使用STL算法对时间序列进行季节性趋势分离，而其中使用到一个称作LOESS的平滑算法。 本文是对1990年一篇有关时间序列分析论文中提及的LOESS算法的部分解读，并基于matlab实现]]></summary></entry></feed>