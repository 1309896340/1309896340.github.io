<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-08-27T19:42:42+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Windwhisper’s Blog</title><subtitle>个人博客，归纳分享所学技术</subtitle><entry><title type="html">C++内存管理</title><link href="http://localhost:4000/2024/08/27/c++-STL%E5%AE%B9%E5%99%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html" rel="alternate" type="text/html" title="C++内存管理" /><published>2024-08-27T00:00:00+08:00</published><updated>2024-08-27T00:00:00+08:00</updated><id>http://localhost:4000/2024/08/27/c++%20STL%E5%AE%B9%E5%99%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86</id><content type="html" xml:base="http://localhost:4000/2024/08/27/c++-STL%E5%AE%B9%E5%99%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><![CDATA[<h1 id="stl容器内存管理">STL容器内存管理</h1>

<p>在使用STL容器时，需要面对各种可能数据类型进行管理，它们有的是基本数据类型，有的是结构体、有的是类对象，也有的是这些类型的指针，或是其他更加复杂的复合形式。在如此复杂的情形下，稍有不慎就会导致野指针、内存泄漏等问题，本文就如何正确处理这些问题做一个归纳总结。</p>

<h2 id="问题引出">问题引出</h2>

<h3 id="栈变量与堆变量">栈变量与堆变量</h3>

<p>声明在栈上的变量，其生命周期被限制在各自的作用域上，脱离作用域，变量自动释放</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>     <span class="c1">// a作用域的开始</span>
    <span class="c1">// a存在的作用域</span>
<span class="p">}</span>   <span class="c1">// 函数返回，a自动释放</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="c1">// a 不存在于函数外的作用域名</span>
    <span class="n">func</span><span class="p">();</span>
    <span class="c1">// a 不存在于函数外的作用域名</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>声明在堆上的变量，即便指向它的指针被释放，堆变量也仍然存在，只是程序再也无法控制这段内存，所以被称为<strong>内存泄漏</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>
    <span class="c1">// 申请但没有释放，内存泄漏</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">func</span><span class="p">();</span>
    <span class="c1">// ptr在func()返回时被释放，再也没有任何方法访问new申请的int内存空间</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里要注意的是</p>
<ol>
  <li>在 <code class="language-plaintext highlighter-rouge">func()</code> 中，<code class="language-plaintext highlighter-rouge">ptr</code> 是栈变量，而 <code class="language-plaintext highlighter-rouge">ptr</code> 指向的内存空间是堆空间</li>
  <li><code class="language-plaintext highlighter-rouge">ptr</code> 在 <code class="language-plaintext highlighter-rouge">func()</code> 返回时会自动释放，而 <code class="language-plaintext highlighter-rouge">ptr</code> 指向的内存不会</li>
</ol>

<p>因此，动态内存(堆内存)的使用，必须有始有终。</p>

<ul>
  <li>在C语言中，有 <code class="language-plaintext highlighter-rouge">malloc()</code> 就有 <code class="language-plaintext highlighter-rouge">free()</code></li>
  <li>在C++中，有 <code class="language-plaintext highlighter-rouge">new</code> 就有 <code class="language-plaintext highlighter-rouge">delete</code></li>
</ul>

<p>两者必须一一对应，否则：</p>

<ul>
  <li>“申请”比”释放”多：内存泄漏</li>
  <li>“申请”比”释放”少：多次释放</li>
</ul>

<h2 id="动态内存谁来管">动态内存谁来管？</h2>

<h3 id="自动和手动">自动和手动</h3>

<ol>
  <li>在C语言中，对于使用了动态内存的代码封装，一般都有一对明确的”初始化”和”销毁”操作，例如文件io操作中的 <code class="language-plaintext highlighter-rouge">open()</code> 和 <code class="language-plaintext highlighter-rouge">close()</code></li>
  <li>在c++中，一般在构造函数中申请堆内存，在析构函数中释放堆内存(需要手动编写释放逻辑)。</li>
</ol>

<p>c++中，类的实例化分为”栈实例化”与”堆实例化”</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="nl">public:</span>
        <span class="n">A</span><span class="p">()</span><span class="o">:</span><span class="n">data</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">){}</span>
        <span class="o">~</span><span class="n">A</span><span class="p">(){</span><span class="k">delete</span> <span class="n">data</span><span class="p">;}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">A</span> <span class="n">a</span><span class="p">;</span>                <span class="c1">// 栈实例化，调用构造，a.data申请动态内存</span>
    <span class="n">A</span> <span class="o">*</span><span class="n">pa</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="p">;</span>      <span class="c1">// 堆实例化，调用构造，pa-&gt;data申请动态内存</span>
    <span class="n">A</span> <span class="o">*</span><span class="n">pa_ok</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">pa_ok</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// 栈变量a自动释放，触发析构函数释放a.data指向的堆内存</span>
    <span class="c1">// 栈变量pa自动释放，但是*pa和pa-&gt;data都没有释放，这两个堆内存空间泄漏</span>
    <span class="c1">// 栈变量pa_ok自动释放，在这之前，析构函数被自动调用</span>
    <span class="c1">// pa_ok-&gt;data指向的堆空间先释放，而后pa_ok指向的声明在堆空间上的A实例被释放，最后栈变量pa_ok被释放</span>
<span class="p">}</span>
</code></pre></div></div>

<p>正因为动态内存的管理中同时存在着”自动”和”手动”两种行为，因此很容易出现”多释放”和”漏释放”两种情况。</p>

<p>因此，明确谁是这块堆空间的实际管理者，非常重要。</p>

<h3 id="指针的备份">指针的备份</h3>

<p>指针是堆内存的控制杆(handler)，丢失了控制杆就丢失了堆内存(泄漏)。然而，指针可以不唯一，这就导致了<strong>多重释放</strong>的潜在风险。</p>

<h4 id="一个典型的错误示例">一个典型的错误示例</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="nl">public:</span>
        <span class="n">A</span><span class="p">()</span><span class="o">:</span><span class="n">data</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">){</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"构造函数初始化 this=%#x data=%#x</span><span class="se">\\</span><span class="s">n"</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="o">~</span><span class="n">A</span><span class="p">(){</span>
            <span class="k">delete</span> <span class="n">data</span><span class="p">;</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"析构函数调用 this=%#x</span><span class="se">\\</span><span class="s">n"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">func_value</span><span class="p">(</span><span class="n">A</span> <span class="n">p</span><span class="p">){}</span>       <span class="c1">// 空函数，只为了演示值传递的效果</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">func_value</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// 在结束时会发生报错</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>严谨地来说，”指针”是存储地址的变量，但有时为了表述方便，会直接称呼”地址”为”指针”，因为我们倾向于将变量的概念等同于其存储的值的概念，这在一定程度上造成了混淆，需要结合语境进行区分。例如，指针传递实际上是地址值的传递。</p>
</blockquote>

<p>以上代码在执行到主函数的返回时会发生报错，报错位置在类A析构函数的 <code class="language-plaintext highlighter-rouge">delete data;</code> 行</p>

<h4 id="发生了什么">发生了什么？</h4>

<p>类对象的值传递默认为”浅拷贝”，即拷贝所有成员变量的”值”，对指针而言，地址值的复制意味着多了一个指针指向同一块堆内存</p>

<pre><code class="language-mermaid">    graph LR
    ptr1[a.data] --&gt; a[堆内存]
    ptr2[p.data] --&gt; a
</code></pre>

<p>对象的值传递导致指针也复制了一份，而函数的形式参数同时也是该函数的局部变量，还是个栈变量，当 <code class="language-plaintext highlighter-rouge">func_value()</code> 中</p>]]></content><author><name></name></author><summary type="html"><![CDATA[STL容器内存管理]]></summary></entry><entry><title type="html">Github Pages上的Mermaid和LaTeX渲染方案</title><link href="http://localhost:4000/2024/08/19/Github-Pages%E4%B8%8A%E7%9A%84Mermaid%E5%92%8CLaTeX%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88.html" rel="alternate" type="text/html" title="Github Pages上的Mermaid和LaTeX渲染方案" /><published>2024-08-19T00:00:00+08:00</published><updated>2024-08-19T00:00:00+08:00</updated><id>http://localhost:4000/2024/08/19/Github%20Pages%E4%B8%8A%E7%9A%84Mermaid%E5%92%8CLaTeX%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88</id><content type="html" xml:base="http://localhost:4000/2024/08/19/Github-Pages%E4%B8%8A%E7%9A%84Mermaid%E5%92%8CLaTeX%E6%B8%B2%E6%9F%93%E6%96%B9%E6%A1%88.html"><![CDATA[<h3 id="问题引出">问题引出</h3>

<p>2022年，GitHub主站通过workflow提供了<a href="https://github.blog/developer-skills/github/include-diagrams-markdown-files-mermaid/">mermaid支持</a>，然而该服务尚未在GitHub Pages上得到支持。</p>

<p>在原生jekyll中，可以通过插件的方式实现Mermaid和LaTeX表达式等内容的渲染，而在Github Pages中部署的jekyll默认只启用<a href="https://pages.github.com/versions/">白名单</a>中的插件，其允许使用的插件非常有限，jekyll-mermaid等插件不在其中。标准的Markdown语法也并不支持LaTeX数学公式的渲染，同样没有相关插件支持。</p>

<h3 id="解决方案">解决方案</h3>

<p>参考博客 <a href="https://juejin.cn/post/7208046833329930300">如何让 GitHub Pages 中通过 Markdown 编辑的博客支持 Mermaid？</a> 中的做法：在jekyll项目的 <code class="language-plaintext highlighter-rouge">_includes</code> 目录（如果没有就手动创建该目录）下创建一个 <code class="language-plaintext highlighter-rouge">.html</code> 文件用来加载外部CDN服务的Mermaid脚本，如 <code class="language-plaintext highlighter-rouge">mermaid_support.html</code>。内容如下</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"module"</span><span class="nt">&gt;</span>
    <span class="k">import</span> <span class="nx">mermaid</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">https://cdn.jsdelivr.net/npm/mermaid@10.0.2/+esm</span><span class="dl">'</span><span class="p">;</span>
    <span class="nx">mermaid</span><span class="p">.</span><span class="nx">initialize</span><span class="p">({</span> <span class="na">startOnLoad</span><span class="p">:</span> <span class="kc">false</span> <span class="p">});</span>
    <span class="k">await</span> <span class="nx">mermaid</span><span class="p">.</span><span class="nx">run</span><span class="p">({</span>
        <span class="na">querySelector</span><span class="p">:</span> <span class="dl">'</span><span class="s1">.language-mermaid</span><span class="dl">'</span><span class="p">,</span>
    <span class="p">});</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>
<p>此时还不能生效，需要将其加载到目标页面中。</p>

<p>jekyll加载 <code class="language-plaintext highlighter-rouge">xxx.md</code> 文件时，会读取其上方的 <code class="language-plaintext highlighter-rouge">layout: xxx</code> 配置项，如这一项不存在，则默认为 <code class="language-plaintext highlighter-rouge">layout: post</code>，即加载 <code class="language-plaintext highlighter-rouge">_layouts</code> 下的 <code class="language-plaintext highlighter-rouge">post.html</code>。</p>

<blockquote>
  <p>Github Pages的jekyll所<a href="https://pages.github.com/themes/">支持的Theme</a>中，参考它们库中的 <code class="language-plaintext highlighter-rouge">_layouts</code> 目录，这是在部署到Github Pages时默认载入且不会出现在本地的文件，按照<a href="https://jekyllrb.com/docs/themes/">jekyll官方文档-Theme</a>的描述，通过在本地创建对应的目录和同名的文件以覆盖默认文件，实现主题的定制化。</p>
</blockquote>

<p>GitHub Pages所支持的主题通常包含 <code class="language-plaintext highlighter-rouge">default.html</code> 和 <code class="language-plaintext highlighter-rouge">post.html</code> 两个layout，而在我们的 <code class="language-plaintext highlighter-rouge">XXX.md</code> 中又导入了 <code class="language-plaintext highlighter-rouge">post.html</code> ，所以三者的关系通常是</p>

<pre><code class="language-mermaid">graph BT
a[XXX.md] --&gt; b[post.html] --&gt; c[default.html]
</code></pre>

<p>从对应的jekyll主题库中复制对应的 <code class="language-plaintext highlighter-rouge">default.html</code> 下来，拷贝到自己的 <code class="language-plaintext highlighter-rouge">_layouts</code> 目录下。打开浏览可以注意到里面的head标签</p>

<p><img src="/assets/images/default.html的内容.png" alt="defalut.html的内容" /></p>

<p><code class="language-plaintext highlighter-rouge">head-custom.html</code> 其实是开放给我们自定义的头部，这样我们可以不用修改默认 <code class="language-plaintext highlighter-rouge">default.html</code>，比较优雅的做法是在 <code class="language-plaintext highlighter-rouge">_include</code> 目录下手动创建一个 <code class="language-plaintext highlighter-rouge">head_custom.html</code> 并写入以下内容</p>

<p><img src="/assets/images/head_custom.html的内容.png" alt="head_custom.html的内容" /></p>

<p>这样，当我们在 <code class="language-plaintext highlighter-rouge">xxx.md</code> 的导言区（用上下三横杠包围的区域）中定义 <code class="language-plaintext highlighter-rouge">mermaid: true</code> 时，这个渲染就会生效。这么做可以手动启停该渲染，在不需要的时候不启用可以优化页面加载速度，但要注意默认值是 <code class="language-plaintext highlighter-rouge">mermaid: false</code>，每次使用都要手动定义，嫌麻烦可以去掉首尾两行。</p>

<p>最后，<code class="language-plaintext highlighter-rouge">bundle exec jekyll serve</code> 启动即可看到mermaid被正确渲染</p>

<p>代码：</p>

<p><img src="/assets/images/mermaid代码.png" alt="mermaid代码" /></p>

<p>渲染结果：</p>

<p><img src="/assets/images/mermaid渲染结果.png" alt="mermaid渲染结果" /></p>
<blockquote>
  <p>博主这里使用了<a href="https://github.com/pages-themes/hacker">jekyll-theme-hacker</a>主题，并进行了一些css的个人定制</p>
</blockquote>

<p>同样，参考博客 <a href="https://www.cnblogs.com/tungsten106/p/17953452/github_page_add_mathjax">Github page数学公式无法正常显示解决方案(MathJax)</a> 通过类似的做法实现对LaTeX公式的渲染</p>]]></content><author><name></name></author><summary type="html"><![CDATA[问题引出]]></summary></entry><entry><title type="html">二叉树平衡调整</title><link href="http://localhost:4000/2024/08/17/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B0%83%E6%95%B4.html" rel="alternate" type="text/html" title="二叉树平衡调整" /><published>2024-08-17T00:00:00+08:00</published><updated>2024-08-17T00:00:00+08:00</updated><id>http://localhost:4000/2024/08/17/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B0%83%E6%95%B4</id><content type="html" xml:base="http://localhost:4000/2024/08/17/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B0%83%E6%95%B4.html"><![CDATA[<h2 id="不平衡二叉树的4种基本情形">不平衡二叉树的4种基本情形</h2>
<ul>
  <li><a href="#不平衡二叉树的4种基本情形">不平衡二叉树的4种基本情形</a>
    <ul>
      <li><a href="#ll型">LL型</a></li>
      <li><a href="#rr型">RR型</a></li>
      <li><a href="#lr型">LR型</a></li>
      <li><a href="#rl型">RL型</a></li>
    </ul>
  </li>
</ul>

<h3 id="ll型">LL型</h3>

<pre><code class="language-mermaid">graph TB
root--&gt;a--&gt;b--&gt;c--&gt;Z
a--&gt;X
b--&gt;Y
c--&gt;W
</code></pre>

<p>变换步骤：<code class="language-plaintext highlighter-rouge">a</code> 相对 <code class="language-plaintext highlighter-rouge">b</code> 做 <code class="language-plaintext highlighter-rouge">右旋</code> 变换</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">a-&gt;left = b-&gt;right</code></li>
  <li><code class="language-plaintext highlighter-rouge">b-&gt;right = a</code></li>
  <li><code class="language-plaintext highlighter-rouge">root-&gt;next = b</code></li>
</ol>

<pre><code class="language-mermaid">graph TB
root--&gt;b--&gt;c--&gt;Z
c--&gt;W
b--&gt;a--&gt;Y
a--&gt;X
</code></pre>

<h3 id="rr型">RR型</h3>

<pre><code class="language-mermaid">graph TB
root--&gt;a--&gt;X
a--&gt;b--&gt;Y
b--&gt;c--&gt;Z
c--&gt;W
</code></pre>

<p>变换步骤：<code class="language-plaintext highlighter-rouge">a</code> 相对 <code class="language-plaintext highlighter-rouge">b</code> 做 <code class="language-plaintext highlighter-rouge">左旋</code> 变换</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">a-&gt;right = b-&gt;left</code></li>
  <li><code class="language-plaintext highlighter-rouge">b-&gt;left = a</code></li>
  <li><code class="language-plaintext highlighter-rouge">root-&gt;next = b</code></li>
</ol>

<pre><code class="language-mermaid">graph TB
root--&gt;b--&gt;a--&gt;X
a--&gt;Y
b--&gt;c--&gt;Z
c--&gt;W
</code></pre>

<h3 id="lr型">LR型</h3>

<pre><code class="language-mermaid">graph TB
root--&gt;a--&gt;b--&gt;Y
a--&gt;X
b--&gt;c--&gt;Z
c--&gt;W
</code></pre>

<p>分步变换：</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">b</code> 相对 <code class="language-plaintext highlighter-rouge">c</code> 做 <code class="language-plaintext highlighter-rouge">左旋</code> 变换</li>
  <li><code class="language-plaintext highlighter-rouge">a</code> 相对 <code class="language-plaintext highlighter-rouge">c</code> 做 <code class="language-plaintext highlighter-rouge">右旋</code> 变换</li>
</ol>

<pre><code class="language-mermaid">graph TB
root--&gt;a--&gt;c--&gt;b--&gt;Y
a--&gt;X
b--&gt;Z
c--&gt;W
</code></pre>

<pre><code class="language-mermaid">graph TB
root--&gt;c--&gt;b--&gt;Y
b--&gt;Z
c--&gt;a--&gt;W
a--&gt;X
</code></pre>

<p>一步到位法:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">b-&gt;right = c-&gt;left</code></li>
  <li><code class="language-plaintext highlighter-rouge">c-&gt;left = b</code></li>
  <li><code class="language-plaintext highlighter-rouge">a-&gt;left = c-&gt;right</code></li>
  <li><code class="language-plaintext highlighter-rouge">c-&gt;right = a</code></li>
  <li><code class="language-plaintext highlighter-rouge">root-&gt;next = c</code></li>
</ol>

<h3 id="rl型">RL型</h3>

<pre><code class="language-mermaid">graph TB
root--&gt;a--&gt;X
a--&gt;b--&gt;c--&gt;Z
b--&gt;Y
c--&gt;W
</code></pre>

<p>分步变换：</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">b</code> 相对 <code class="language-plaintext highlighter-rouge">c</code> 做 <code class="language-plaintext highlighter-rouge">右旋</code> 变换</li>
  <li><code class="language-plaintext highlighter-rouge">a</code> 相对 <code class="language-plaintext highlighter-rouge">c</code> 做 <code class="language-plaintext highlighter-rouge">左旋</code> 变换</li>
</ol>

<pre><code class="language-mermaid">graph TB
root--&gt;a--&gt;X
a--&gt;c--&gt;Z
c--&gt;b--&gt;W
b--&gt;Y
</code></pre>

<pre><code class="language-mermaid">graph TB
root--&gt;c--&gt;a--&gt;X
a--&gt;Z
c--&gt;b--&gt;W
b--&gt;Y
</code></pre>

<p>一步到位法：</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">a-&gt;right = c-&gt;left</code></li>
  <li><code class="language-plaintext highlighter-rouge">c-&gt;left = a</code></li>
  <li><code class="language-plaintext highlighter-rouge">b-&gt;left = c-&gt;right</code></li>
  <li><code class="language-plaintext highlighter-rouge">c-&gt;right = b</code></li>
  <li><code class="language-plaintext highlighter-rouge">root-&gt;next = c</code></li>
</ol>]]></content><author><name></name></author><summary type="html"><![CDATA[不平衡二叉树的4种基本情形 不平衡二叉树的4种基本情形 LL型 RR型 LR型 RL型]]></summary></entry><entry><title type="html">LOESS：局部散点图平滑(Locally Estimated Scatterplot Smoothing) matlab实现</title><link href="http://localhost:4000/2023/07/11/LOESS-%E5%B1%80%E9%83%A8%E6%95%A3%E7%82%B9%E5%9B%BE%E5%B9%B3%E6%BB%91(Locally-Estimated-Scatterplot-Smoothing)-matlab%E5%AE%9E%E7%8E%B0.html" rel="alternate" type="text/html" title="LOESS：局部散点图平滑(Locally Estimated Scatterplot Smoothing) matlab实现" /><published>2023-07-11T00:00:00+08:00</published><updated>2023-07-11T00:00:00+08:00</updated><id>http://localhost:4000/2023/07/11/LOESS%EF%BC%9A%E5%B1%80%E9%83%A8%E6%95%A3%E7%82%B9%E5%9B%BE%E5%B9%B3%E6%BB%91(Locally%20Estimated%20Scatterplot%20Smoothing)%20matlab%E5%AE%9E%E7%8E%B0</id><content type="html" xml:base="http://localhost:4000/2023/07/11/LOESS-%E5%B1%80%E9%83%A8%E6%95%A3%E7%82%B9%E5%9B%BE%E5%B9%B3%E6%BB%91(Locally-Estimated-Scatterplot-Smoothing)-matlab%E5%AE%9E%E7%8E%B0.html"><![CDATA[<h2 id="前言">前言</h2>
<p>最近在学习时间序列预测，需要使用STL算法对时间序列进行季节性趋势分离，而其中使用到一个称作LOESS的平滑算法。
本文是对1990年一篇有关时间序列分析论文中提及的LOESS算法的部分解读，并基于matlab实现</p>

<p><a href="https://scholar.google.co.jp/scholar_url?url=http://www.nniiem.ru/file/news/2016/stl-statistical-model.pdf&amp;hl=zh-CN&amp;sa=X&amp;ei=oqOsZNqyCaSK6rQPhqKGiAE&amp;scisig=ABFrs3yOkcuHV4Q4StOGq9vmlX1X&amp;oi=scholarr">STL: A Seasonal-Trend Decomposition Procedure Based on Loess</a></p>

<h2 id="数据来源">数据来源</h2>
<p>在google earth engine上获取2002年到2018年共17年的全球温度月(平均)数据，空间分辨率0.5°，时间分辨率1月
(获取数据需要特殊网络环境)</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">d2</span> <span class="o">=</span> <span class="nx">ee</span><span class="p">.</span><span class="nx">ImageCollection</span><span class="p">(</span><span class="dl">"</span><span class="s2">ECMWF/ERA5/DAILY</span><span class="dl">"</span><span class="p">).</span><span class="nx">filterDate</span><span class="p">(</span><span class="dl">"</span><span class="s2">2002-01-01</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">2019-01-01</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">start_t</span> <span class="o">=</span> <span class="nx">ee</span><span class="p">.</span><span class="nb">Date</span><span class="p">(</span><span class="dl">"</span><span class="s2">2002-01-01</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">sq</span> <span class="o">=</span> <span class="nx">ee</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nx">sequence</span><span class="p">({</span>
    <span class="na">start</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="na">end</span><span class="p">:</span> <span class="mi">12</span><span class="o">*</span><span class="mi">17</span>
<span class="p">});</span>
<span class="kd">var</span> <span class="nx">d2</span> <span class="o">=</span> <span class="nx">ee</span><span class="p">.</span><span class="nx">ImageCollection</span><span class="p">(</span><span class="nx">sq</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">m</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">start_d</span> <span class="o">=</span> <span class="nx">start_t</span><span class="p">.</span><span class="nx">advance</span><span class="p">(</span><span class="nx">ee</span><span class="p">.</span><span class="nb">Number</span><span class="p">(</span><span class="nx">m</span><span class="p">).</span><span class="nx">subtract</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="dl">"</span><span class="s2">month</span><span class="dl">"</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">end_d</span> <span class="o">=</span> <span class="nx">start_d</span><span class="p">.</span><span class="nx">advance</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="dl">"</span><span class="s2">month</span><span class="dl">"</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">new_d</span> <span class="o">=</span> <span class="nx">d2</span><span class="p">.</span><span class="nx">filterDate</span><span class="p">(</span><span class="nx">start_d</span><span class="p">,</span><span class="nx">end_d</span><span class="p">).</span><span class="nx">mean</span><span class="p">()</span>
        <span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">"</span><span class="s2">system:time_start</span><span class="dl">"</span><span class="p">,</span><span class="nx">start_d</span><span class="p">.</span><span class="nx">millis</span><span class="p">());</span>
    <span class="k">return</span> <span class="nx">new_d</span><span class="p">;</span>
<span class="p">}));</span>
<span class="kd">var</span> <span class="nx">TMP</span> <span class="o">=</span> <span class="nx">d2</span><span class="p">.</span><span class="nx">select</span><span class="p">(</span><span class="dl">"</span><span class="s2">mean_2m_air_temperature</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">Export</span><span class="p">.</span><span class="nx">image</span><span class="p">.</span><span class="nx">toDrive</span><span class="p">({</span>
    <span class="na">image</span><span class="p">:</span> <span class="nx">TMP</span><span class="p">.</span><span class="nx">toBands</span><span class="p">(),</span>
    <span class="na">crs</span><span class="p">:</span> <span class="dl">"</span><span class="s2">EPSG:4326</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">dimensions</span><span class="p">:</span> <span class="dl">"</span><span class="s2">720x360</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">region</span><span class="p">:</span> <span class="nx">ee</span><span class="p">.</span><span class="nx">Geometry</span><span class="p">.</span><span class="nx">Rectangle</span><span class="p">([[</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span><span class="o">-</span><span class="mi">90</span><span class="p">],[</span><span class="mi">180</span><span class="p">,</span><span class="mi">90</span><span class="p">]],</span><span class="kc">null</span><span class="p">,</span><span class="kc">false</span><span class="p">),</span>
    <span class="na">fileNamePrefix</span><span class="p">:</span> <span class="nx">dataname</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="p">});</span>
</code></pre></div></div>
<p>文件大小186MB，文件格式tif，可以在matlab中使用<code class="language-plaintext highlighter-rouge">imread(filename)</code>直接读取</p>

<h2 id="算法解读">算法解读</h2>
<p>LOESS基于局部加权回归(Local Weighted Regression)原理，对散点图的某个x坐标进行局部的而非全局的加权回归，而后估计在给定x坐标上的值。
LOESS包含两个关键参数，<code class="language-plaintext highlighter-rouge">q</code>表示在给定x坐标周围参与局部多项式回归的近邻点个数，<code class="language-plaintext highlighter-rouge">d</code>表示进行局部多项式回归的多项式次数。</p>
<blockquote>
  <p>这里的x做可以取连续值，因为它只需计算与最近的采样点的距离即可得到回归权重，通过近邻点来估计当前位置点(类似KNN的思想)。</p>
</blockquote>

<p>下图演示了参数为q=7,d=1的LOESS平滑过程
<img src="https://img2023.cnblogs.com/blog/3228693/202307/3228693-20230711100809285-1628529796.gif" alt="image" />
蓝点为原始序列，红点为待估计的原始序列点，红圈为选中参与局部回归的近邻点，绿点为平滑后的估计值</p>

<h2 id="算法实现">算法实现</h2>
<p>读取tif文件并取其中一个像素点的时间序列，该序列长度为$12\times 17=204$，为17年的月采样序列</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span> <span class="o">=</span> <span class="nb">imread</span><span class="p">(</span><span class="s2">"TMP_monthly.tif"</span><span class="p">);</span>
<span class="n">y</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:),</span><span class="mi">1</span><span class="p">,[]);</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">numel</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="c1">% 这里约定x和y为行向量</span>
</code></pre></div></div>
<p>定义q和d，这里选择以7个近邻点做1次多项式(线性)回归</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">q</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="n">d</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>
<p>首先对<code class="language-plaintext highlighter-rouge">x</code>和<code class="language-plaintext highlighter-rouge">y</code>进行一个缩放和中心化(Z-Score标准化)，目的是为了在计算最小二乘解时避免数据溢出</p>
<blockquote>
  <p>实测如果不进行缩放，在x值超过120时会导致最小二乘解结果产生偏差，即便数据以64位浮点的double类型存储也无法解决，而预先进行缩放是个人实测有效的方法，不过要注意在最后进行反变换恢复成原始序列。</p>
  <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">y_mean</span> <span class="o">=</span> <span class="nb">mean</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="n">y_std</span> <span class="o">=</span> <span class="nb">std</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="n">x_mean</span> <span class="o">=</span> <span class="nb">mean</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">x_std</span> <span class="o">=</span> <span class="nb">std</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">ys</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">y_mean</span><span class="p">)/</span><span class="n">y_std</span><span class="p">;</span>
<span class="n">xs</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x_mean</span><span class="p">)/</span><span class="n">x_std</span><span class="p">;</span>
</code></pre></div>  </div>
  <p>在遍历序列中每个采样点之前声明一个数组用于存储平滑后的序列</p>
  <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">yhat</span> <span class="o">=</span> <span class="n">nan</span> <span class="o">*</span> <span class="nb">ones</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">ys</span><span class="p">));</span>
</code></pre></div>  </div>
  <p>循环体中的内容如下</p>
  <div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">numel</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">xs</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="c1">% 1. 选择与xi近邻的q个y值不为nan的点</span>
    <span class="c1">% 2. 计算近邻元素权值</span>
    <span class="c1">% 3. 计算加权回归系数</span>
    <span class="c1">% 4. 计算估计值</span>
<span class="k">end</span>
</code></pre></div>  </div>
  <p>第一步的操作是为了保证时间序列存在空缺值的情况下仍能进行，LOESS的基本逻辑就是采用最近邻点进行回归估计，因此能有效填补空缺值。</p>
</blockquote>

<p>实现思路：使用<code class="language-plaintext highlighter-rouge">mink()</code>函数来取得<code class="language-plaintext highlighter-rouge">q</code>个x上距离<code class="language-plaintext highlighter-rouge">abs(xs-xi)</code>最小值点，循环判断这些点的y值是否存在nan，如果存在，则每次多取一个点(stq加1)，直到取到<code class="language-plaintext highlighter-rouge">q</code>个符合要求的近邻点。其中<code class="language-plaintext highlighter-rouge">I</code>为近邻点的索引数组，<code class="language-plaintext highlighter-rouge">B</code>为近邻点x值与$x_i$的距离数组.</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">stq</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
<span class="p">[</span><span class="n">B</span><span class="p">,</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="nb">mink</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">xs</span> <span class="o">-</span> <span class="n">xi</span><span class="p">),</span><span class="n">stq</span><span class="p">);</span>
<span class="n">idxs</span> <span class="o">=</span> <span class="o">~</span><span class="nb">isnan</span><span class="p">(</span><span class="n">ys</span><span class="p">(</span><span class="n">I</span><span class="p">));</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">idxs</span><span class="p">);</span>
<span class="k">while</span> <span class="nb">numel</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">~=</span><span class="n">q</span>
    <span class="n">stq</span> <span class="o">=</span> <span class="n">stq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">[</span><span class="n">B</span><span class="p">,</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="nb">mink</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">xs</span> <span class="o">-</span> <span class="n">xi</span><span class="p">),</span><span class="n">stq</span><span class="p">);</span>
    <span class="n">idxs</span> <span class="o">=</span> <span class="o">~</span><span class="nb">isnan</span><span class="p">(</span><span class="n">ys</span><span class="p">(</span><span class="n">I</span><span class="p">));</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">idxs</span><span class="p">);</span>
<span class="k">end</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">idxs</span><span class="p">);</span>
</code></pre></div></div>
<p>上述得到的<code class="language-plaintext highlighter-rouge">B</code>中的元素，为从小到大排列的距离值，与索引序列<code class="language-plaintext highlighter-rouge">I</code>中的元素一一对应，<code class="language-plaintext highlighter-rouge">B(1)</code>是与$x_i$最近元素的x轴距离，相反<code class="language-plaintext highlighter-rouge">B(end)</code>是与$x_i$最远距离。通过<code class="language-plaintext highlighter-rouge">B</code>可以计算近邻点的权值，但首先要将<code class="language-plaintext highlighter-rouge">B</code>整体除以最远距离<code class="language-plaintext highlighter-rouge">B(end)</code>进行<code class="language-plaintext highlighter-rouge">[0,1]</code>范围归一化</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">weight</span> <span class="o">=</span> <span class="n">W</span><span class="p">(</span><span class="n">B</span><span class="p">/</span><span class="n">B</span><span class="p">(</span><span class="k">end</span><span class="p">));</span>

<span class="k">function</span> <span class="n">res</span> <span class="o">=</span> <span class="n">W</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">idx1</span> <span class="o">=</span> <span class="n">u</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">idx2</span> <span class="o">=</span> <span class="n">u</span><span class="o">&lt;</span><span class="mi">1</span> <span class="o">&amp;</span> <span class="n">u</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">idx3</span> <span class="o">=</span> <span class="n">u</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">;</span>

    <span class="n">res</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">u</span><span class="p">),</span><span class="s2">"like"</span><span class="p">,</span><span class="n">u</span><span class="p">);</span>
    <span class="n">res</span><span class="p">(</span><span class="n">idx1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">res</span><span class="p">(</span><span class="n">idx2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">u</span><span class="p">(</span><span class="n">idx2</span><span class="p">)</span><span class="o">.^</span><span class="mi">3</span><span class="p">)</span><span class="o">.^</span><span class="mi">3</span><span class="p">;</span>
    <span class="n">res</span><span class="p">(</span><span class="n">idx3</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">end</span>
</code></pre></div></div>
<p>这里的<code class="language-plaintext highlighter-rouge">W</code>函数是文献中采用的三次权函数，有的文献中采用指数
\(W(u) = \begin{cases}
(1-u^3)^3&amp;, 0\leq u\lt 1\\
0&amp;, u\geq 1
\end{cases}\)
计算得到的<code class="language-plaintext highlighter-rouge">weight</code>一般是像如下所示的以1开头逐步递减至0的序列</p>
<pre><code class="language-output">weight =
	1.0000, 0.8930, 0.8930, 0.3485, 0.3485, 0.0000, 0.0000
</code></pre>
<p>它们就是对数组<code class="language-plaintext highlighter-rouge">I</code>对应索引元素的权重，比如当前循环处理第9个元素，那么其近邻的7个点从距离由近到远的元素索引和距离分别是</p>
<pre><code class="language-output">I =
    9, 8, 10, 7, 11, 6, 12
B =
    0, 0.0169, 0.0169, 0.0339, 0.0339, 0.0508, 0.0508
</code></pre>
<p>即最近的点赋予最高的权值，而在<code class="language-plaintext highlighter-rouge">q</code>之外的点赋予$0$的权值</p>

<p>然后是计算加权回归系数，先根据多项式阶数<code class="language-plaintext highlighter-rouge">d</code>构造线性方程组$Ax=b$中的A矩阵<code class="language-plaintext highlighter-rouge">xmat</code>，它是由近邻点x值序列构造的矩阵，其第$1$列为常数列，第$2$列为$1$次项，……，第$k+1$列为$k$次项</p>

<p>$Ax=b$中的b向量<code class="language-plaintext highlighter-rouge">ymat</code>为近邻点的y值序列</p>

<p>调用matlab的<code class="language-plaintext highlighter-rouge">lsqminnorm(A,b)</code>函数计算最小范数最小二乘解，相比<code class="language-plaintext highlighter-rouge">A\b</code>具有更高的数值稳定性，同时相比<code class="language-plaintext highlighter-rouge">pinv(A)*b</code>也有更高的计算效率</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xmat</span> <span class="o">=</span> <span class="nb">ones</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">d</span>
    <span class="n">xmat</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">xs</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.^</span><span class="n">k</span><span class="p">;</span>
<span class="k">end</span>
<span class="n">ymat</span> <span class="o">=</span> <span class="n">ys</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">'</span><span class="p">;</span>
<span class="n">tp</span> <span class="o">=</span> <span class="n">xmat</span><span class="o">'</span> <span class="o">*</span> <span class="nb">diag</span><span class="p">(</span><span class="n">weight</span><span class="p">);</span>
<span class="nb">what</span> <span class="o">=</span> <span class="nb">lsqminnorm</span><span class="p">(</span><span class="n">tp</span> <span class="o">*</span> <span class="n">xmat</span><span class="p">,</span> <span class="n">tp</span> <span class="o">*</span> <span class="n">ymat</span><span class="p">);</span>
</code></pre></div></div>
<p>最后使用回归系数估计$x_i$点的$\hat y$值</p>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xpre</span> <span class="o">=</span> <span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">d</span>
    <span class="n">xpre</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">xi</span><span class="o">^</span><span class="n">k</span><span class="p">;</span>
<span class="k">end</span>
<span class="n">yhat</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">xpre</span> <span class="o">*</span> <span class="nb">what</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="完整代码包含可视化">完整代码(包含可视化)</h2>
<div class="language-matlab highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">clear</span><span class="p">;</span>
<span class="nb">clf</span><span class="p">;</span>

<span class="n">data</span> <span class="o">=</span> <span class="nb">imread</span><span class="p">(</span><span class="s2">"TMP_monthly.tif"</span><span class="p">);</span>
<span class="n">y</span> <span class="o">=</span> <span class="nb">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,:),</span><span class="mi">1</span><span class="p">,[]);</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">numel</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

<span class="n">q</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="n">d</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">%% LOESS(x,y,q,d)</span>
<span class="n">y_mean</span> <span class="o">=</span> <span class="nb">mean</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="n">y_std</span> <span class="o">=</span> <span class="nb">std</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="n">x_mean</span> <span class="o">=</span> <span class="nb">mean</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">x_std</span> <span class="o">=</span> <span class="nb">std</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">ys</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">y_mean</span><span class="p">)/</span><span class="n">y_std</span><span class="p">;</span>
<span class="n">xs</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x_mean</span><span class="p">)/</span><span class="n">x_std</span><span class="p">;</span>

<span class="nb">set</span><span class="p">(</span><span class="nb">gca</span><span class="p">,</span><span class="s2">"position"</span><span class="p">,[</span><span class="mf">0.05</span><span class="p">,</span><span class="mf">0.12</span><span class="p">,</span><span class="mf">0.93</span><span class="p">,</span><span class="mf">0.8</span><span class="p">])</span>
<span class="nb">set</span><span class="p">(</span><span class="nb">gcf</span><span class="p">,</span><span class="s2">"position"</span><span class="p">,</span><span class="mi">1000</span><span class="o">*</span><span class="p">[</span><span class="mf">2.6903</span>   <span class="o">-</span><span class="mf">0.2103</span>    <span class="mf">1.000</span>    <span class="mf">0.3500</span><span class="p">]);</span>
<span class="nb">set</span><span class="p">(</span><span class="nb">gcf</span><span class="p">,</span><span class="s2">"name"</span><span class="p">,</span><span class="s2">"Temperature"</span><span class="p">);</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s2">"time/Month"</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s2">"temperature/K"</span><span class="p">);</span>

<span class="nb">hold</span> <span class="n">on</span><span class="p">;</span>

<span class="nb">plot</span><span class="p">(</span><span class="n">xs</span><span class="o">*</span><span class="n">x_std</span><span class="o">+</span><span class="n">x_mean</span><span class="p">,</span><span class="n">ys</span><span class="o">*</span><span class="n">y_std</span><span class="o">+</span><span class="n">y_mean</span><span class="p">,</span><span class="s1">'-o'</span><span class="p">,</span><span class="s1">'markersize'</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="s1">'MarkerFaceColor'</span><span class="p">,</span><span class="s1">'b'</span><span class="p">);</span>
<span class="nb">xlim</span><span class="p">([</span><span class="n">xs</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">x_std</span><span class="o">+</span><span class="n">x_mean</span><span class="p">,</span><span class="n">xs</span><span class="p">(</span><span class="k">end</span><span class="p">)</span><span class="o">*</span><span class="n">x_std</span><span class="o">+</span><span class="n">x_mean</span><span class="p">]);</span>
<span class="nb">title</span><span class="p">(</span><span class="nb">sprintf</span><span class="p">(</span><span class="s2">"Locally Estimated Scatterplot Smoothing (q=%d,d=%d)"</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">d</span><span class="p">));</span>
<span class="nb">xlabel</span><span class="p">(</span><span class="s2">"time/Month"</span><span class="p">);</span>
<span class="nb">ylabel</span><span class="p">(</span><span class="s2">"temperature/K"</span><span class="p">);</span>

<span class="n">axlim</span> <span class="o">=</span> <span class="nb">axis</span><span class="p">;</span>

<span class="n">yhat</span> <span class="o">=</span> <span class="n">nan</span> <span class="o">*</span> <span class="nb">ones</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">ys</span><span class="p">));</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">numel</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">xs</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

    <span class="c1">% 选择q个y上不为nan的值</span>
    <span class="n">stq</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
    <span class="p">[</span><span class="n">B</span><span class="p">,</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="nb">mink</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">xs</span> <span class="o">-</span> <span class="n">xi</span><span class="p">),</span><span class="n">stq</span><span class="p">);</span>
    <span class="n">idxs</span> <span class="o">=</span> <span class="o">~</span><span class="nb">isnan</span><span class="p">(</span><span class="n">ys</span><span class="p">(</span><span class="n">I</span><span class="p">));</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">idxs</span><span class="p">);</span>
    <span class="k">while</span> <span class="nb">numel</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">~=</span><span class="n">q</span>
        <span class="n">stq</span> <span class="o">=</span> <span class="n">stq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">[</span><span class="n">B</span><span class="p">,</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="nb">mink</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">xs</span> <span class="o">-</span> <span class="n">xi</span><span class="p">),</span><span class="n">stq</span><span class="p">);</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="o">~</span><span class="nb">isnan</span><span class="p">(</span><span class="n">ys</span><span class="p">(</span><span class="n">I</span><span class="p">));</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">idxs</span><span class="p">);</span>
    <span class="k">end</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">idxs</span><span class="p">);</span>
    
    <span class="c1">% 近邻元素权重</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">W</span><span class="p">(</span><span class="n">B</span><span class="p">/</span><span class="n">B</span><span class="p">(</span><span class="k">end</span><span class="p">));</span>
    
    <span class="c1">% 最小二乘回归</span>
    <span class="n">xmat</span> <span class="o">=</span> <span class="nb">ones</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">d</span>
        <span class="n">xmat</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">xs</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.^</span><span class="n">k</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="n">ymat</span> <span class="o">=</span> <span class="n">ys</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">'</span><span class="p">;</span>
    <span class="n">tp</span> <span class="o">=</span> <span class="n">xmat</span><span class="o">'</span> <span class="o">*</span> <span class="nb">diag</span><span class="p">(</span><span class="n">weight</span><span class="p">);</span>
    <span class="nb">what</span> <span class="o">=</span> <span class="nb">lsqminnorm</span><span class="p">(</span><span class="n">tp</span> <span class="o">*</span> <span class="n">xmat</span><span class="p">,</span> <span class="n">tp</span> <span class="o">*</span> <span class="n">ymat</span><span class="p">);</span>
    <span class="n">xpre</span> <span class="o">=</span> <span class="nb">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">d</span>
        <span class="n">xpre</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">xi</span><span class="o">^</span><span class="n">k</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="n">yhat</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">xpre</span> <span class="o">*</span> <span class="nb">what</span><span class="p">;</span>
    
    <span class="c1">% 绘图部分</span>
    <span class="k">if</span> <span class="nb">exist</span><span class="p">(</span><span class="s2">"selp"</span><span class="p">,</span><span class="s2">"var"</span><span class="p">)</span>
        <span class="nb">delete</span><span class="p">(</span><span class="n">selp</span><span class="p">);</span>
        <span class="nb">delete</span><span class="p">(</span><span class="n">selp1</span><span class="p">);</span>
        <span class="nb">delete</span><span class="p">(</span><span class="n">regc</span><span class="p">);</span>
    <span class="k">end</span>
    <span class="n">selp</span> <span class="o">=</span> <span class="nb">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">*</span><span class="n">x_std</span><span class="o">+</span><span class="n">x_mean</span><span class="p">,</span><span class="n">ys</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">*</span><span class="n">y_std</span><span class="o">+</span><span class="n">y_mean</span><span class="p">,</span><span class="s1">'ro'</span><span class="p">);</span>
    <span class="nb">plot</span><span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">x_std</span><span class="o">+</span><span class="n">x_mean</span><span class="p">,</span><span class="n">yhat</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">y_std</span><span class="o">+</span><span class="n">y_mean</span><span class="p">,</span><span class="s1">'g.'</span><span class="p">,</span><span class="s2">"markersize"</span><span class="p">,</span><span class="mi">16</span><span class="p">);</span>
    <span class="n">selp1</span> <span class="o">=</span> <span class="nb">plot</span><span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">x_std</span><span class="o">+</span><span class="n">x_mean</span><span class="p">,</span><span class="n">ys</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">y_std</span><span class="o">+</span><span class="n">y_mean</span><span class="p">,</span><span class="s1">'r.'</span><span class="p">,</span><span class="s2">"markersize"</span><span class="p">,</span><span class="mi">22</span><span class="p">);</span>

    <span class="c1">% 绘制回归曲线</span>
    <span class="n">xpre</span> <span class="o">=</span> <span class="nb">ones</span><span class="p">(</span><span class="nb">numel</span><span class="p">(</span><span class="n">I</span><span class="p">),</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">d</span>
        <span class="n">xpre</span><span class="p">(:,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">xs</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.^</span><span class="n">k</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="n">pdy</span> <span class="o">=</span> <span class="n">xpre</span> <span class="o">*</span> <span class="nb">what</span><span class="p">;</span>
    <span class="n">regc</span> <span class="o">=</span> <span class="nb">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">*</span><span class="n">x_std</span><span class="o">+</span><span class="n">x_mean</span><span class="p">,</span><span class="n">pdy</span><span class="o">*</span><span class="n">y_std</span><span class="o">+</span><span class="n">y_mean</span><span class="p">,</span><span class="s1">'k'</span><span class="p">);</span>
    <span class="nb">axis</span><span class="p">(</span><span class="n">axlim</span><span class="p">);</span>

    <span class="nb">drawnow</span><span class="p">;</span>
    <span class="c1">% pause(0.2);</span>
<span class="k">end</span>

<span class="k">function</span> <span class="n">res</span> <span class="o">=</span> <span class="n">W</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">idx1</span> <span class="o">=</span> <span class="n">u</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">idx2</span> <span class="o">=</span> <span class="n">u</span><span class="o">&lt;</span><span class="mi">1</span> <span class="o">&amp;</span> <span class="n">u</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">idx3</span> <span class="o">=</span> <span class="n">u</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">;</span>

    <span class="n">res</span> <span class="o">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">u</span><span class="p">),</span><span class="s2">"like"</span><span class="p">,</span><span class="n">u</span><span class="p">);</span>
    <span class="n">res</span><span class="p">(</span><span class="n">idx1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">res</span><span class="p">(</span><span class="n">idx2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">u</span><span class="p">(</span><span class="n">idx2</span><span class="p">)</span><span class="o">.^</span><span class="mi">3</span><span class="p">)</span><span class="o">.^</span><span class="mi">3</span><span class="p">;</span>
    <span class="n">res</span><span class="p">(</span><span class="n">idx3</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">end</span>
</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[前言 最近在学习时间序列预测，需要使用STL算法对时间序列进行季节性趋势分离，而其中使用到一个称作LOESS的平滑算法。 本文是对1990年一篇有关时间序列分析论文中提及的LOESS算法的部分解读，并基于matlab实现]]></summary></entry></feed>